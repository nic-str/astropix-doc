# SPI Daisychain Interface

The AstroPix5 SPI Interface is an enhanced version of the [SPI Interface of AstroPix3](../astropix3/spi.md).

The main differences are:

* One 8 Byte frame per hit instead of two 5 Byte frames
* Two new commands Heartbeat and ADC Readout
* All shift registers configurable via SPI
* Improved interrupt logic, monitoring also the chain FIFOs, making it unnecessary to toggle the SPI much longer after the interrupt de-assertion
<!--spi4-start-->
## Controlling FE

AstroPix receives commands via the MOSI line, using the following 8-bit format:

{% include-markdown "../astropix3/spi/format_packet.md" %}

All valid commands are summarized in the table below:

| BIT   | Field   | Description                                                                                   |
|-------|---------|-----------------------------------------------------------------------------------------------|
| [4:0] | Address | 0x00 -  0x14 : Single addresses<br>0x15 - 0x1F : Reserved<br>0x1D: Invalid<br>0x1E: Broadcast |
| [7:5] | Command | 0x01 - NOCMD / IDLE<br>0x02 - Routing: dispatch<br>0x03 - Shift Register Config addresses     |

The IDLE byte represents no specific command and uses an invalid address: 0x1D for the address and 0x1 for IDLE, resulting in **0x3D**.
{% include-markdown "../astropix3/spi/format_idle.md" %}

### Commands

| COMMAND | NAME  | LENGTH | DESCRIPTION   |
|---------|-------|--------|---------------|
| 0x01    | NOCMD | 1 Byte | No Operation |
|0x02|	Address Config|	1 Byte	| Sets the chip address. The chip forwards the command to the next chip with Address = Address + 1.<br>To configure addresses, start with chip "00" by sending 0x40, then send IDLE bytes to keep the clock active and propagate the address down the chain.|
|0x03 |	Shift Register Config	|N Bytes	| Uses the entire SPI frame for shift register configuration. SPI Chip Select must be toggled to send a new command. |
|0x04 |	Heartbeat	|1 Byte	| Request Heartbeat Package from chip via Address or from all chips via Broadcast 0x1E |
|0x05 |	ADC Readout	|1 Byte	| Request acquisition of 8 voltages (2 temperature sensors and 6 bias voltage) from on-chip ADC |

### Shift Register I/O and SPI Command

The shift register interface exposes two clocks, a serial input (SIN), and a load signal to load bits into the registers.
Each bit on the SIN line is clocked through the shift register by toggling Clock 1 and Clock 2 separately. The diagram below illustrates a 3-bit register configuration:

{% include-markdown "../astropix3/spi/format_sr.md" %}

SPI commands generate this sequence as follows:

- The first byte contains the 0x3 command and the target chip or broadcast ID
- Each subsequent byte shifts a 0 or 1 into the shift register. The LSB of each byte is used for Serial In (`8'bxxxxxxx1` or `8'bxxxxxxx0`)
- At the end of the sequence, send a byte with bit[1] = 1 to generate the required Load signal, in this case for the digital config
- When the frame ends, the Load signal returns to 0

{% include-markdown "./spi/format_packet_sr.md" %}


## Reading from the Front-End (FE)

The APS-to-FE path differs from the FE-to-APS path, as it does not process commands. Its sole function is to forward packets down the chain and arbitrate between forwarded packets and those generated by the local readout.

The data format on this path uses a header that includes the Chip ID and a length field, allowing the Arbiter to transmit complete frames without splitting them.

### Hit Packet
A single hit generates a single data frames, which is different to the 2 row and column half hits generated by AstroPix3.

Each frame consists of 7 bytes:
{% include-markdown "./spi/format_packet_hit.md" %}

#### Header Byte
{% include-markdown "../astropix3/spi/format_packet_read.md" %}

- Chip address is set by the routing byte
- Payload length indicates the number of bytes following the header

#### Hit Location

The hit location is a 5 bit binary column and row address sent within the two first bytes after the header.
<!--spi4-stop-->
### ADC Readout

The ADC readout command 0x5 is used to readout 8 voltages, including the 2 temperature sensors and 6 bias voltages (BL, Th, Vcasc2!, GateRef, vminus, Vinj). The chips needs a few milliseconds to acquire the voltages, but it asserts the interrupt when the acquisition is done.

The ADC data is packed into two data frames. The first two Bytes of the first package are 0xFFFE and 0xFFFD for the second package. Therefore, they can also be distinguished from a normal data packet, as the pixel address is 63, 63 which does not correspond to an existing pixel.
{% include-markdown "./spi/format_packet_adcreadout.md" %}

### Heartbeat

The heartbeat command 0x4 can be used to get „sign of life“ and to check if a chip is configured. It can be broadcasted or sent to individual chips via their ID.

The chip answers with a packet similar to the [normal readout data frame](#hit-packet). The first two bytes are 0xFFFF, then the 16 Extrabits from the configuration are sent non-inverted and inverted. The last Byte is the current count of the internal SEU counter. Similar to the ADC readout package, it can also be distinguished from a normal data packet, as the pixel address is 63, 63 which does not correspond to an existing pixel.
{% include-markdown "./spi/format_packet_heartbeat.md" %}


<!--spi4readout-start-->
## Readout procedure

!!! note
    If the chip is not configured and the SPI clock is toggled, you will likely see the [no data case](spi.md#no-data-available), where the chip responds with IDLE bytes. In some cases, you may also receive data generated by noise hits, unless hold is active.
    If you do not receive any data from the chip, check the physical SPI connection.

### Readout Sequence

- Activate the Timestamp Clock and if the integrated PLL is not used also the ToT clocks.
- Send the Routing Byte through the daisy-chain to assign chip IDs
- Send the Shift Register configuration command to configure the chips
- Wait for the interrupt falling edge, with the SPI clock deactivated
- When the interrupt is asserted, start the SPI clock to send dummy bytes (e.g., IDLE 0x3D) to initiate readout
- Continue sending dummy bytes until the interrupt is deasserted
- Deactivate SPI clock again to save power

### Data available for readout

{% include-markdown "../astropix3/spi/timing_spi.md" %}

### No data available

This timing diagram shows the case when hold is low and interrupt is inactive, the chip returns only IDLE bytes because there is no hit data.

{% include-markdown "../astropix3/spi/timing_spi_no_data.md" %}

### Hold active

This timing diagram shows the case when hold is active and interrupt is active, the chip returns only IDLE bytes instead of sending out hit data.

{% include-markdown "../astropix3/spi/timing_spi_hold.md" %}

## Readout Rate Considerations

To select a safe minimum SPI clock frequency, both the expected hit volume and the maximum acceptable readout latency must be considered. The formulas below give minimum values, include an appropriate safety margin when choosing the operating point. Note that the ToA timestamp is 17 bits wide and the daisy-chain arbiter does prioritize forwarded data; both factors relax the required SPI throughput compared to [AstroPix3](../astropix3/spi.md#readout-rate-considerations).

### Minimum Data Rate
Assuming a maximum hit rate HR, the peak data rate  for a row of n chips is
$$
\text{DR} = n \cdot \textnormal{HR} \cdot 8 ~\text{Byte}
$$

Assuming n = 20 and a maximum hit rate HR of 10 Hz/sensor, the data rate DR is 12.8 Kbit/s, requiring a minimum SPI clock frequency of 7 kHz.

### Latency Requirements
Let n be the number of chips in a row and RR the readout rate (RR is twice the SPI clock frequency, as there are 2 MISO lines). The minimum readout latency for a hit originating at the last chip in the row, when only that chip has a hit, is
$$
t_{\text{lat, single hit}} = \dfrac{8 ~\text{Byte} + 2 ~\text{Byte}\cdot (n-1)}{\text{RR}}
$$

If every chip in the row has a stored hit, the minimum latency becomes
$$
t_{\text{lat, all hits}} = \dfrac{8 ~\text{Byte}\cdot n}{\text{RR}}
$$

This latency must be shorter than the wrap time of the 17 bit time-of-arrival counter
$$
t_{\text{lat}} < 2^{17} ~T_{\text{ckts}}
$$
where $T_\textnormal{ckts}$ is the timestamp clock period.

Using $T_\textnormal{ckts} = 1/f_\textnormal{ckts}$ = 1/(20 MHz) and n = 20 gives the following practical numbers: the single-hit case requires RR ~ 56 kbit/s (SPI clock = 28 kHz). In the case where every chip has a stored hit, RR ~ 195 kbit/s (SPI clock = 98 kHz).

If a slower timestamp clock can be tolerated, the required SPI clock frequency can be reduced accordingly.

### Calculator

<div class="md-card md-shadow--2dp" style="max-width: 520px; padding: 1em; border: 1px solid #ccc; border-radius: 6px;">
  <h3>Readout Rate Calculator</h3>

  <label>
    Number of chips (n):<br>
    <input type="number" id="n" value="20" min="1" step="1" class="md-input" oninput="this.value = Math.round(this.value);">
  </label><br><br>

  <label>
    Hit rate per chip (HR) [Hz]:<br>
    <input type="number" id="hr" value="10" min="0" step="0.1" class="md-input">
  </label><br><br>

  <!-- <label>
    ToA counter width [bits]:<br>
    <input type="number" id="toa" value="17" min="1">
  </label><br><br> -->

  <label>
    Timestamp clock period T<sub>ckts</sub> [s]:<br>
    <input type="number" id="tckts" min="0" value="50e-9" step="1e-9" class="md-input">
    <small class="md-hint">(default = 1 / (20 MHz) = 50 ns)</small>
  </label><br><br>

  <button onclick="calculateRR(17,8)" class="md-button md-button--primary">Calculate</button>

  <hr>

  <div id="output"></div>
</div>
<!--spi4readout-stop-->
