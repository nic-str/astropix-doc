# SPI Daisychain Interface

## Controlling FE

AstroPix receives commands via the MOSI line, using the following 8-bit format:

{% include-markdown "./spi/format_packet.md" %}

All valid commands are summarized in the table below:

| BIT   | Field   | Description                                                                                   |
|-------|---------|-----------------------------------------------------------------------------------------------|
| [4:0] | Address | 0x00 -  0x14 : Single addresses<br>0x15 - 0x1F : Reserved<br>0x1D: Invalid<br>0x1E: Broadcast |
| [7:5] | Command | 0x01 - NOCMD / IDLE<br>0x02 - Routing: dispatch<br>0x03 - Shift Register Config addresses     |

The IDLE byte represents no specific command and uses an invalid address: 0x1D for the address and 0x1 for IDLE, resulting in **0x3D**.
{% include-markdown "./spi/format_idle.md" %}

### Commands

| COMMAND | NAME  | LENGTH | DESCRIPTION   |
|---------|-------|--------|---------------|
| 0x01    | NOCMD | 1 Byte | No Operation |
|0x02|	Address Config|	1 Byte	| Sets the chip address. The chip forwards the command to the next chip with Address = Address + 1.<br>To configure addresses, start with chip "00" by sending 0x40, then send IDLE bytes to keep the clock active and propagate the address down the chain.|
|0x03 |	Shift Register Config	|N Bytes	| Uses the entire SPI frame for shift register configuration. SPI Chip Select must be toggled to send a new command. |


### Shift Register I/O and SPI Command

The shift register interface exposes two clocks, a serial input (SIN), and a load signal to load bits into the registers.
Each bit on the SIN line is clocked through the shift register by toggling Clock 1 and Clock 2 separately. The diagram below illustrates a 3-bit register configuration:

{% include-markdown "./spi/format_sr.md" %}

SPI commands generate this sequence as follows:

- The first byte contains the 0x3 command and the target chip or broadcast ID
- Each subsequent byte shifts a 0 or 1 into the shift register. The LSB of each byte is used for Serial In (`8'bxxxxxxx1` or `8'bxxxxxxx0`)
- At the end of the sequence, send a byte with bit[1] = 1 to generate the Load signal
- When the frame ends, the Load signal returns to 0


## Reading from the Front-End (FE)

The APS-to-FE path differs from the FE-to-APS path, as it does not process commands. Its sole function is to forward packets down the chain and arbitrate between forwarded packets and those generated by the local readout.

The data format on this path uses a header that includes the Chip ID and a length field, allowing the Arbiter to transmit complete frames without splitting them.

### Hit Packet
A single hit generates two data frames: one for the row and one for the column. Because rows and columns are logically OR'd, two hits in the same column but different rows occurring simultaneously will produce only one column frame, but two row frames.

Each frame consists of 5 bytes:
{% include-markdown "./spi/format_packet_hit.md" %}

#### Header Byte
{% include-markdown "./spi/format_packet_read.md" %}

- Chip address is set by the routing byte
- Payload length indicates the number of bytes following the header

#### Hit Location Byte

{% include-markdown "./spi/format_packet_hit_location.md" %}

- MSB is for Row/Column identification
    - 1: Column
    - 0: Row
- Lower 6 bits specify the row or column address

## Readout procedure

!!! note
    If the chip is not configured and the SPI clock is toggled, you will likely see the [no data case](spi.md#no-data-available), where the chip responds with IDLE bytes. In some cases, you may also receive data generated by noise hits, unless hold is active.
    If you do not receive any data from the chip, check the physical SPI connection.

### Readout Sequence

- Activate the Timestamp Clock and ToT clocks.
- Send the Routing Byte through the daisy-chain to assign chip IDs
- Send the Shift Register configuration command to configure the chips
- Wait for the interrupt falling edge, with the SPI clock deactivated
- When the interrupt is asserted, start the SPI clock to send dummy bytes (e.g., IDLE 0x3D) to initiate readout
- Continue sending dummy bytes until the interrupt is deasserted and no packets are detected for approximately 40 bytes
- Deactivate SPI clock again to save power

### Data available for readout

{% include-markdown "./spi/timing_spi.md" %}

### No data available

This timing diagram shows the case when hold is low and interrupt is inactive, the chip returns only IDLE bytes because there is no hit data.

{% include-markdown "./spi/timing_spi_no_data.md" %}

### Hold active

This timing diagram shows the case when hold is active and interrupt is active, the chip returns only IDLE bytes instead of sending out hit data.

{% include-markdown "./spi/timing_spi_hold.md" %}

## Readout Rate Considerations

To select a safe minimum SPI clock frequency, both the expected hit volume and the maximum acceptable readout latency must be considered. The formulas below give minimum values, include an appropriate safety margin when choosing the operating point. Note that the ToA timestamp is only 8 bits wide and the daisy-chain arbiter does not fully prioritize forwarded data; both factors increase the required SPI throughput.

### Minimum Data Rate
Assuming a maximum hit rate HR, the peak data rate  for a row of n chips is
$$
\text{DR} = n \cdot \textnormal{HR} \cdot 2 \cdot 5 ~\text{Byte}
$$

Assuming n = 20 and a maximum hit rate HR of 10 Hz/sensor, the data rate DR is 16 Kbit/s, requiring a minimum SPI clock frequency of 8 kHz.

### Latency Requirements
Let n be the number of chips in a row and RR the readout rate (RR is twice the SPI clock frequency, as there are 2 MISO lines). The minimum readout latency for a hit originating at the last chip in the row, when only that chip has a hit, is
$$
t_{\text{lat, single hit}} = \dfrac{2\cdot 5 ~\text{Byte} + 2 ~\text{Byte}\cdot (n-1)}{\text{RR}}
$$

If every chip in the row has a stored hit, the minimum latency becomes
$$
t_{\text{lat, all hits}} = \dfrac{2\cdot 5 ~\text{Byte} \cdot n}{\text{RR}}
$$

This latency must be shorter than the wrap time of the 8-bit time-of-arrival counter
$$
t_{\text{lat}} < 2^8 ~T_{\text{ckts}}
$$
where $T_\textnormal{ckts}$ is the timestamp clock period.

Using $T_\textnormal{ckts}$ = 1/2 MHz and n = 20 gives the following practical numbers: the single-hit case requires RR ~ 1.4 Mbit/s (SPI clock = 0.7 MHz). In the case where every chip has a stored hit, RR ~ 6.4 Mbit/s (SPI clock = 3.2 MHz).

If a slower timestamp clock can be tolerated, the required SPI clock frequency can be reduced accordingly.

