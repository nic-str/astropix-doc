{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"AstroPix ASIC Documentation","text":""},{"location":"index.html#astropix-asic-documentation","title":"AstroPix ASIC Documentation","text":"<p>This is the documentation website for AstroPix a low power, high dynamic range High Voltage Monolithic Active Pixel Sensor (HVMAPS), initially developed for NASA's proposed All-sky Medium-Energy Gamma-ray Observatory eXplorer AMEGO-X.</p> <p>User manuals for AstroPix2 to AstroPix5 can be found here:</p> <ul> <li>AstroPix2</li> <li>AstroPix3</li> <li>AstroPix4</li> <li>AstroPix5</li> </ul> <p>More infomations on how to operate the chips can be found in the Measurement Setup chapter.</p>"},{"location":"astropix2/index.html","title":"AstroPix2 Specifications","text":""},{"location":"astropix2/index.html#astropix2-specifications","title":"AstroPix2 Specifications","text":"<p>Submission Status: Submitted in 2021</p>"},{"location":"astropix2/index.html#summary","title":"Summary","text":""},{"location":"astropix2/index.html#supplies","title":"Supplies","text":"<ul> <li>Analog Supply VDDA: 1.8V</li> <li>Analog Supply VSSA: 1.2V</li> <li>Digital Supply VDDD: 1.8V</li> <li>Analog Ground GNDA</li> <li>Digital Ground GNDD</li> <li>Sensor Reverse Bias Voltage: 0 to -400V with respect to GNDA</li> <li>External Bias Voltages: 4 * (0-1.8V configurable)</li> </ul>"},{"location":"astropix2/index.html#pixel-matrix","title":"Pixel Matrix","text":"<ul> <li>250u Pixel Pitch and 250u Pixel Size</li> <li>35 x 35 pixels</li> <li>NMOS amplifier</li> <li>Pixel Dynamic Range 20 keV - 250 keV</li> <li>Pixel Comparator Outputs Row/Column OR wired</li> </ul>"},{"location":"astropix2/index.html#matrix-digitisation","title":"Matrix Digitisation","text":"<ul> <li>Time over Threshold (ToT) counter 12 bit @ 200Mhz (1% @ 700keV) for each column/row (Pixels wired OR in row/column)</li> <li>Time of Arrival timestamp counter 8 bit @ 2Mhz</li> </ul>"},{"location":"astropix2/index.html#digital-interface","title":"Digital Interface","text":"<ul> <li>TS Clock: 2Mhz with half period max. delay over ~20 Chip row</li> <li>LVDS Clock: Independently running in each chip</li> <li>Common Interrupt for row wake-up</li> <li>Common Hold for data discarding</li> <li>Unique ID for each APS</li> <li>5 QSPI I/O: Quad  SPI in Daisy Chain</li> <li>CLK 20 Mhz : Chip to Chip</li> <li>MOSI: Chip to Chip (Left to right in the chain)</li> <li>MISO[1:0] : Chip to Chip (right to left in the chain)</li> <li>CS (Chips Select): right to left to synchronize Chip output and input stages</li> </ul>"},{"location":"astropix2/index.html#auxiliary-sensors","title":"Auxiliary Sensors","text":"<ul> <li>4 unbuffered temperature sensors</li> </ul>"},{"location":"astropix2/configuration.html","title":"Configuration Registers","text":"<p>Note</p> <p>For programing, the first bit interrupt_pushpull has to be sent last, and the last bit in this list first.</p> <p>The chip can be programmed directly via the shift register interface or through the SPI SR Command.</p>"},{"location":"astropix2/configuration.html#digital-config","title":"Digital Config","text":"Field Name Bits Default Value Description interrupt_pushpull 1 1 1: push-pull output for single chip setup 0: open-drain for single or multi chip en_inj 18 0 unused reset 1 0 unused extrabits 15 0 unused"},{"location":"astropix2/configuration.html#analog-config","title":"Analog Config","text":"Field Name Bits Default Value Description DisHiDR 1 1 1: Amplifier high-gain mode 0: Amplifier bilinear gain mode q01 1 0 Biasblock enable (use default values) qon0 1 0 Biasblock enable (use default values) qon1 1 1 Biasblock enable (use default values) qon2 1 0 Biasblock enable (use default values) qon3 1 1 Biasblock enable (use default values) blres 6 0 Highpass filter bandwidth 0: low 63: high nu1 6 0 unused vn1 6 20 Amplifier input NMOS bias vnfb 6 1 Feedback current vnfoll 6 10 Amplifier operating point feedback nu5 6 0 unused nu6 6 0 unused nu7 6 0 unused nu8 6 0 unused vn2 6 0 Additional Amplifier input NMOS bias to increase maximum current vnfoll2 6 1 Low pass filter bandwidth 0: low 63: high vnbias 6 10 N-well bias vpload 6 5 Amplifier load current vnpmos 6 0 Amplifier input PMOS bias vncomp 6 2 Comparator bias current vpfoll 6 30 Ampout multiplexer current nu16 6 0 unused vprec 6 30 Levelshifter Pullup current vnrec 6 30 Levelshifter Receiver load current"},{"location":"astropix2/configuration.html#column-config","title":"Column Config","text":"<p>Each column incorporates a 38 bit shift register, and each columns are connected in series starting at column 0 to column 34.</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 1,  name: '', attr: \"InjRow\"},\n            {bits: 35,  name: '', attr: 'Pixel Comp Disable'},\n            {bits: 1,  name: '' , attr: 'InjCol'},\n            {bits: 1,  name: '', attr: 'AmpOut'},\n        ], config: { bits: 38},\n    }\n    </code>\n</pre> <p>For column n from 0 to 34:</p> <ul> <li>Bit 37: AmpOut Mux enable</li> <li>Bit 36: Enable Column for injection</li> <li>Bit 35-1: Enable Pixel comparators in column<ul> <li>Bit 35 is row 34</li> <li>Bit 1 is row 0</li> </ul> </li> <li>Bit 0: Enable Row n for Injection</li> </ul> <p>Warning</p> <p>Set AmpOut bit only in one column</p>"},{"location":"astropix2/pins.html","title":"Pins","text":"<p>Warning</p> <ul> <li>Unused inputs must be tied to ground unless otherwise specified.</li> <li>Unused outputs should be left unconnected.</li> <li>Unused bidirectional pins should be left unconnected.</li> </ul>"},{"location":"astropix2/pins.html#recommended-operating-parameters","title":"Recommended Operating Parameters","text":""},{"location":"astropix2/pins.html#supply-voltages","title":"Supply Voltages","text":"Parameter Min Typ Max Typ. Current Comment vdda! 1.62 V 1.8 V 1.98 V 2 mA All pads internally connected - add decoupling on each pad if possible vdd! 1.62 V 1.8 V 1.98 V 5 mA All pads internally connected - add decoupling on each pad if possible vssa! 1.1 V 1.2 V 1.98 V - Not implemented vminuspix 0 V 0.7 V 1.98 V &lt; 100 uA Voltage regulator must be able to sink current HV 0 V -120 V -190 V &lt; 100 nA All pads internally connected - Negative Bias for Pixel Sensors <p>Warning</p> <p>The low voltage supplies vdda!, vdd! and vssa! should be turned on at the same time, otherwise the chip can be damaged due to high currents caused by forward biased diodes.</p>"},{"location":"astropix2/pins.html#lvds-receiver","title":"LVDS Receiver","text":"Parameter Min Typ Max Comment Common mode voltage 0.8 V 1.2V Differential amplitude 0.2 V 0.4 V Input capacitance ~3 pF"},{"location":"astropix2/pins.html#pins","title":"Pins","text":"<p>Note</p> <p>Pins starting with B are located at the bottom, L on the left and R on the right side of the chip</p> Pin Name Supply TYPE Description B1 sub HV Power B2 subdpads HV Power Don't connect B3 gnda! Power B4 vdda! 1.8 V Power B5 sample_clock_p Input LVDS &lt;200 MHz Clock for ToT counter  (Connect to gnd! if Single ended clock is used) - P/N can be swapped B6 sample_clock_n Input LVDS &lt;200 MHz Clock for ToT counter  (Connect to vdd! if Single ended clock is used) - P/N can be swapped B7 vdd! 1.8 V Power B8 gnd! Power B9 interrupt Output (Open-Drain/pushpull see interrupt_pushpull config bit) Active low status signal (0: data to read out 1: no data to read out) - Needs 10 kOhm pullup to vdd! in Open-Drain mode B10 res_n Input Active low global reset B11 timestamp_clk Input B12 hold Output B13 sr_CK1 Input SPI Fallback: Clock1 for Chip Configuration B14 sr_CK2 Input SPI Fallback: Clock2 for Chip Configuration B15 sr_LOAD Input SPI Fallback: Load for Chip Configuration B16 sr_SIN Input SPI Fallback: In for Chip Configuration B17 sr_RB Input SPI Fallback: Readback for Chip Configuration B18 sr_SOUT Output SPI Fallback: Out for Chip Configuration B19 vdd! 1.8 V Power B20 gnd! Power B21 vdda! 1.8 V Power B22 gnda! Power B23 gnda! Power B24 VPBias BiDir Reference current B25 pamp BiDir Don't connect B26 blpix BiDir Comparator baseline voltage B27 NC NC B28 gnda! Power B29 vdda! 1.8 V Power B30 Inj BiDir Analog Injection B31 VCasc2! BiDir Load cascode voltage B32 ThPix BiDir Comparator threshold voltage for NMOS Amplifier pixels B33 vminuspix 0.9 V Power Level shifter low level B34 gnda! Power B35 vdda! 1.8 V Power B36 SFOut Output Source Follower to buffer signal from analog multiplexer, needs external load resistor 2 kOhm to gnda! B37 vdda_temp 1.8 V Power B38 gnda_temp Power B39 Vtemp1 Output B40 sub HV Power B41 subapads HV Power Don't connect B42 ring1 Power B43 ring2 Power B44 ring3 Power B45 ring4 Power L1 SPI_left_MISO1 Output SPI Peripheral MISO1 L2 SPI_left_MISO0 Output SPI Peripheral MISO0 L3 SPI_left_MOSI Input SPI Peripheral MOSI L4 SPI_left_CLK Input SPI Clock input L5 SPI_left_CSN Input SPI Chip Select (active-low) input L6 sample_clock_left Output Single Ended ToT clock input R1 sample_clock_right Output Don't use - internal connection to Pad missing R2 SPI_right_CSN Output SPI Chip Select (active-low) output R3 SPI_right_CLK Output SPI Clock output R4 SPI_right_MOSI Output SPI Sender MOSI R5 SPI_right_MISO0 Input SPI Sender MISO0 R6 SPI_right_MISO1 Input SPI Sender MISO1"},{"location":"astropix2/pixelelectronics.html","title":"Pixel Electronics","text":""},{"location":"astropix2/pixelelectronics.html#pixel-electronics","title":"Pixel Electronics","text":""},{"location":"astropix2/pixelelectronics.html#csa-and-bandpass-filter","title":"CSA and Bandpass Filter","text":"<p>A simplified schematic of the pixel electronics is shown below:</p> <p></p> <p>Reverse biased sensor diode formed deep n-well and p-substrate, cascoded charge sensitive amplifier (CSA) and bandpass filter</p> <p>The sensing element is the pn-diode formed by the p-substrate and the deep n-well of the pixel. By applying a high reverse bias, a thick depletion region is created. Electrons generated by charged particles or photons in the depletion region are quickly transported to the collection n-well by drift, due to the strong electric field. A charge sensitive amplifier (CSA) is capacitively coupled to the collection n-well, it is implemented as a cascode amplifier with a cascode load and an NFET input device. The feedback capacitance of around 500 aF is formed by the parasitic drain junction capacitance of the load cascode PFET. A voltage signal is produced dependent on the input charge and this capacitance. Assuming that the amplifier has a high open loop gain \\(A_{0}\\) with \\(A_{O} C_{fb} &gt;&gt; C_{det}\\) this can be simplified to: $$ v_{out} \\approx \\dfrac{Q}{C_{fb}} $$ A second, much larger 15 fF feedback capacitance C1 is connected from the amplifier input to the voltage node between the load transistors. If the cascode transistor is in saturation, the impedance from the output to this node is high, but if there is a large input signal, the cascoded transistor goes into the linear region and there is a low impedance path from the output to this node. Therefore, for a large input signal the two capacitors appear to be in parallel resulting in a reduced closed-loop gain of: $$ v_{out} \\approx \\dfrac{Q}{C_{fb}+C_{fb2}} $$ The feedback capacitance is continuously discharged by a constant current source VNFB, which results in a linear decay of the output pulse. The amplifiers input DC operating point is set by the source-follower SF1. The second source-follower SF2 acts as a low pass filter. Due to its non-linearity, the rising edge has a fast rise time, but the falling edge because the load current source INFOLL2 is biased with a low current. A higher current increases the low pass filter bandwidth, resulting in a steeper slope i.e. shorter time-over-threshold (ToT) but also higher noise. From the output of SF2 the signal is capacitively coupled through a Metal-Insulator-Metal capacitor to AmpOutAC. The DC level is set by the voltage DAC blpix, which is connected to the signal though a small current source, acting as a high pass filter together with the coupling capacitance.</p>"},{"location":"astropix2/pixelelectronics.html#comparator-and-level-shifter","title":"Comparator and Level shifter","text":"<p>The signal path from the comparator input to the receiver output is shown below: </p> <p>CMOS comparator and Level shifter</p> <p>The comparator is a two stage amplifier with the first stage being a NFET differential amplifier with a PFET current source load and the second stage being a common-source amplifier to increase the gain. The analog voltage pulse goes into the comparator and gets compared to the threshold voltage Vth. The comparator bias current is set by the current digital-to-analog converter (DAC) VNCOMP. The output is a positive voltage pulse with Vlow 0V and VHigh 1.8V. Due to mismatch, the differential amplifier in the comparator is not totally symmetric. This results in a shift of the effective threshold to the value set by Vth. A compensation mechanism is implemented since AstroPix4, consisting of a 3bit current DAC which can be tuned to make the tail currents in the differential stage equal. The following stage is an open drain NFET, pulled up by the current source VPREC. This NFET converts the positive pulse to a negative pulse. The source of the NFET is connected to Vminuspix (normally 0.7 - 1V), which reduces the signal amplitude from 1.8V to 0.8 - 1.1V. A higher signal amplitude, i.e. a lower value of vminuspix reduces the propagation delay but also increases EMI at the same time. In the hit buffer of every pixel, the signal is converted back to the full amplitude by a PFET common-source amplifier. The output signal is a positive pulse with a fast rise time and a fall time which is determined by the discharge current VNREC.</p>"},{"location":"astropix2/readout.html","title":"Matrix Readout","text":""},{"location":"astropix2/readout.html#columnrow-hit-buffer","title":"Column/Row Hit Buffer","text":"<p>Hitbuffer showing ToA and ToT capturing, reset after read and hold masking</p> <p>The above circuit is implemented for every row and column. An incoming active low hit signal enables the clockgate of the ToT counter, starting the ToT measurement and latching the ToA timestamp. At the same time, the negative edge flipflop on top is triggered, activating the interrupt and deactivating the clock gate of the ToT counter. At the trailing edge of the hit pulse, a positive edge flipflop is triggered, signalizing to the readout state machine, that there is a hit available for readout. If hold is active this hit flag is masked.</p> <p>As soon as the SPI clock is toggled by the DAQ, the readout state machine starts to transfer the hits from the hit buffer to the SPI Interface. When this process is completed, the flipflops are reset and ready for the next hit.</p>"},{"location":"astropix2/spi.html","title":"SPI Interface","text":""},{"location":"astropix2/spi.html#spi-daisychain-interface","title":"SPI Daisychain Interface","text":""},{"location":"astropix2/spi.html#controlling-fe","title":"Controlling FE","text":"<p>AstroPix receives commands via the MOSI line, using the following 8-bit format:</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 5,  name: 'Chip Address (5b)', type: 4},\n            {bits: 3,  name: 'Command (3b)', type: 3},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre> <p>All valid commands are summarized in the table below:</p> BIT Field Description [4:0] Address 0x00 -  0x14 : Single addresses0x15 - 0x1F : Reserved0x1D: Invalid0x1E: Broadcast [7:5] Command 0x01 - NOCMD / IDLE0x02 - Routing: dispatch0x03 - Shift Register Config addresses <p>The IDLE byte represents no specific command and uses an invalid address: 0x1D for the address and 0x1 for IDLE, resulting in 0x3D.</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 5,  name: '0x1D', type: 4, attr: \"Address\"},\n            {bits: 3,  name: '0x1', type: 3, attr: \"Command\"},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre>"},{"location":"astropix2/spi.html#commands","title":"Commands","text":"COMMAND NAME LENGTH DESCRIPTION 0x01 NOCMD 1 Byte No Operation 0x02 Address Config 1 Byte Sets the chip address. The chip forwards the command to the next chip with Address = Address + 1.To configure addresses, start with chip \"00\" by sending 0x40, then send IDLE bytes to keep the clock active and propagate the address down the chain. 0x03 Shift Register Config N Bytes Uses the entire SPI frame for shift register configuration. SPI Chip Select must be toggled to send a new command."},{"location":"astropix2/spi.html#shift-register-io-and-spi-command","title":"Shift Register I/O and SPI Command","text":"<p>The shift register interface exposes two clocks, a serial input (SIN), and a load signal to load bits into the registers. Each bit on the SIN line is clocked through the shift register by toggling Clock 1 and Clock 2 separately. The diagram below illustrates a 3-bit register configuration:</p> <pre>    <code>\n    { signal : [\n        {name: 'Ck1',    wave: '0.10..10..10...'},\n        {name: 'Ck2',     wave: '0...10..10..10.'},\n        {name: 'SIN',     wave: 'x5..x5..x5..x..', data: ['Bit 0','Bit 1', 'Bit 2']},\n        {name: 'Load',   wave: '0............10'},\n    ], config:{hscale: 2}\n}\n    </code>\n</pre> <p>SPI commands generate this sequence as follows:</p> <ul> <li>The first byte contains the 0x3 command and the target chip or broadcast ID</li> <li>Each subsequent byte shifts a 0 or 1 into the shift register. The LSB of each byte is used for Serial In (<code>8'bxxxxxxx1</code> or <code>8'bxxxxxxx0</code>)</li> <li>At the end of the sequence, send a byte with bit[1] = 1 to generate the Load signal</li> <li>When the frame ends, the Load signal returns to 0</li> </ul>"},{"location":"astropix2/spi.html#reading-from-the-front-end-fe","title":"Reading from the Front-End (FE)","text":"<p>The APS-to-FE path differs from the FE-to-APS path, as it does not process commands. Its sole function is to forward packets down the chain and arbitrate between forwarded packets and those generated by the local readout.</p> <p>The data format on this path uses a header that includes the Chip ID and a length field, allowing the Arbiter to transmit complete frames without splitting them.</p>"},{"location":"astropix2/spi.html#hit-packet","title":"Hit Packet","text":"<p>A single hit generates two data frames: one for the row and one for the column. Because rows and columns are logically OR'd, two hits in the same column but different rows occurring simultaneously will produce only one column frame, but two row frames.</p> <p>Each frame consists of 5 bytes:</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 1,  name: 'Header', type: 2},\n            {bits: 1,  name: 'Hit Location', type: 3},\n            {bits: 1,  name: 'ToA Timestamp', type: 4},\n            {bits: 1,  name: 'ToT MSB', type: 5},\n            {bits: 1,  name: 'ToT LSB', type: 5},\n        ], config:{bits: 5, vflip: true}\n    }\n    </code>\n</pre>"},{"location":"astropix2/spi.html#header-byte","title":"Header Byte","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 3,  name: 'Payload (3b)', type: 2},\n            {bits: 5,  name: 'Chip Address (5b)', type: 2},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre> <ul> <li>Chip address is set by the routing byte</li> <li>Payload length indicates the number of bytes following the header</li> </ul>"},{"location":"astropix2/spi.html#hit-location-byte","title":"Hit Location Byte","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 6,  name: 'Row/Col Number', type: 3},\n            {bits: 1,  name: 'Reserved', type: 3},\n            {bits: 1,  name: '0:Row 1:Col', type: 3},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre> <ul> <li>MSB is for Row/Column identification<ul> <li>1: Column</li> <li>0: Row</li> </ul> </li> <li>Lower 6 bits specify the row or column address</li> </ul>"},{"location":"astropix2/spi.html#readout-procedure","title":"Readout procedure","text":"<p>Note</p> <p>If the chip is not configured and the SPI clock is toggled, you will likely see the no data case, where the chip responds with IDLE bytes. In some cases, you may also receive data generated by noise hits, unless hold is active. If you do not receive any data from the chip, check the physical SPI connection.</p>"},{"location":"astropix2/spi.html#readout-sequence","title":"Readout Sequence","text":"<ul> <li>Activate the Timestamp Clock and ToT clocks.</li> <li>Send the Routing Byte through the daisy-chain to assign chip IDs</li> <li>Send the Shift Register configuration command to configure the chips</li> <li>Wait for the interrupt falling edge, with the SPI clock deactivated</li> <li>When the interrupt is asserted, start the SPI clock to send dummy bytes (e.g., IDLE 0x3D) to initiate readout</li> <li>Continue sending dummy bytes until the interrupt is deasserted and no packets are detected for approximately 40 bytes</li> <li>Deactivate SPI clock again to save power</li> </ul>"},{"location":"astropix2/spi.html#data-available-for-readout","title":"Data available for readout","text":"<pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|..............................'},\n        {name: 'Interrupt',   wave: 'x1...|.0............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...4...4...4...4...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'HEADER Bit 0,2,4,6', 'Hit Location Bit 0,2,4,6', 'ToA Bit 0,2,4,6', 'ToT Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...4...4...4...4...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'HEADER Bit 1,3,5,7', 'Hit Location Bit 1,3,5,7', 'ToA Bit 1,3,5,7','ToT Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix2/spi.html#no-data-available","title":"No data available","text":"<p>This timing diagram shows the case when hold is low and interrupt is inactive, the chip returns only IDLE bytes because there is no hit data.</p> <pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|..............................'},\n        {name: 'Interrupt',   wave: 'x1...|..............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...3...3...3...3...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...3...3...3...3...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix2/spi.html#hold-active","title":"Hold active","text":"<p>This timing diagram shows the case when hold is active and interrupt is active, the chip returns only IDLE bytes instead of sending out hit data.</p> <pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|...1..........................'},\n        {name: 'Interrupt',   wave: 'x1...|.0............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...3...3...3...3...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...3...3...3...3...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix2/spi.html#readout-rate-considerations","title":"Readout Rate Considerations","text":"<p>To select a safe minimum SPI clock frequency, both the expected hit volume and the maximum acceptable readout latency must be considered. The formulas below give minimum values, include an appropriate safety margin when choosing the operating point. Note that the ToA timestamp is only 8 bits wide and the daisy-chain arbiter does not fully prioritize forwarded data; both factors increase the required SPI throughput.</p>"},{"location":"astropix2/spi.html#minimum-data-rate","title":"Minimum Data Rate","text":"<p>Assuming a maximum hit rate HR, the peak data rate  for a row of n chips is $$ \\text{DR} = n \\cdot \\textnormal{HR} \\cdot 2 \\cdot 5 ~\\text{Byte} $$</p> <p>Assuming n = 20 and a maximum hit rate HR of 10 Hz/sensor, the data rate DR is 16 Kbit/s, requiring a minimum SPI clock frequency of 8 kHz.</p>"},{"location":"astropix2/spi.html#latency-requirements","title":"Latency Requirements","text":"<p>Let n be the number of chips in a row and RR the readout rate (RR is twice the SPI clock frequency, as there are 2 MISO lines). The minimum readout latency for a hit originating at the last chip in the row, when only that chip has a hit, is $$ t_{\\text{lat, single hit}} = \\dfrac{2\\cdot 5 ~\\text{Byte} + 2 ~\\text{Byte}\\cdot (n-1)}{\\text{RR}} $$</p> <p>If every chip in the row has a stored hit, the minimum latency becomes $$ t_{\\text{lat, all hits}} = \\dfrac{2\\cdot 5 ~\\text{Byte} \\cdot n}{\\text{RR}} $$</p> <p>This latency must be shorter than the wrap time of the 8-bit time-of-arrival counter $$ t_{\\text{lat}} &lt; 2^8 ~T_{\\text{ckts}} $$ where \\(T_\\textnormal{ckts}\\) is the timestamp clock period.</p> <p>Using \\(T_\\textnormal{ckts}\\) = 1/2 MHz and n = 20 gives the following practical numbers: the single-hit case requires DR ~ 1.4 Mbit/s (SPI clock = 0.7 MHz). In the case where every chip has a stored hit, DR ~ 6.4 Mbit/s (SPI clock = 3.2 MHz).</p> <p>If a slower timestamp clock can be tolerated, the required SPI clock frequency can be reduced accordingly.</p>"},{"location":"astropix3/index.html","title":"AstroPix3 Specifications","text":""},{"location":"astropix3/index.html#astropix3-specifications","title":"AstroPix3 Specifications","text":"<p>Submission Status: Submitted June 2022</p> <p></p> <p>AstroPix3 Layout</p>"},{"location":"astropix3/index.html#summary","title":"Summary","text":""},{"location":"astropix3/index.html#supplies","title":"Supplies","text":"<ul> <li>Analog Supply VDDA: 1.8V</li> <li>Analog Supply VSSA: 1.2V</li> <li>Digital Supply VDDD: 1.8V</li> <li>Analog Ground GNDA</li> <li>Digital Ground GNDD</li> <li>Sensor Reverse Bias Voltage: 0 to -400V with respect to GNDA</li> <li>Integrated Bias Voltage DAC: 4 * (0-1.8V configurable)</li> </ul>"},{"location":"astropix3/index.html#pixel-matrix","title":"Pixel Matrix","text":"<ul> <li>500u Pixel Pitch and 300u Pixel Size</li> <li>35 x 35 pixels</li> <li>first 3 cols PMOS amplifier others NMOS</li> <li>Pixel Dynamic Range 20 keV - 250 keV</li> <li>Noise Floor 5keV (2%@662keV)</li> <li>Pixel Comparator Outputs Row/Column OR wired</li> </ul>"},{"location":"astropix3/index.html#matrix-digitisation","title":"Matrix Digitisation","text":"<ul> <li>Time over Threshold (ToT) counter 12 bit @ 200Mhz (1% @ 700keV) for each column/row (Pixels wired OR in row/column)</li> <li>Time of Arrival timestamp counter 8 bit @ 2Mhz</li> </ul>"},{"location":"astropix3/index.html#digital-interface","title":"Digital Interface","text":"<ul> <li>TS Clock: 2Mhz with half period max. delay over ~20 Chip row</li> <li>LVDS Clock: Independently running in each chip</li> <li>Common Interrupt for row wake-up</li> <li>Common Hold for data discarding</li> <li>Unique ID for each APS</li> <li>5 QSPI I/O: Quad  SPI in Daisy Chain</li> <li>CLK 20 Mhz : Chip to Chip</li> <li>MOSI: Chip to Chip (Left to right in the chain)</li> <li>MISO[1:0] : Chip to Chip (right to left in the chain)</li> <li>CS (Chips Select): right to left to synchronize Chip output and input stages</li> </ul>"},{"location":"astropix3/index.html#auxiliary-sensors","title":"Auxiliary Sensors","text":"<ul> <li>4 unbuffered temperature sensors</li> </ul>"},{"location":"astropix3/configuration.html","title":"Configuration Registers","text":""},{"location":"astropix3/configuration.html#chip-configuration","title":"Chip Configuration","text":"<p>AstroPix3 is configured trough a long shift register, consisting of a configuration for the digital part, the analog part including all current and voltage dacs and the column configuration to disable pixels and selection rows/columns for injection. The first bit in the register is the interrupt_pushpull bit, while bit 37 of the 35th column config is the last bit.</p> <p>Note</p> <p>For programing, the first bit interrupt_pushpull has to be sent last, and the last bit in this list first.</p> <p>The chip can be programmed directly via the shift register interface or through the SPI SR Command.</p>"},{"location":"astropix3/configuration.html#digital-config","title":"Digital Config","text":"Field Name Bits Default Value Description interrupt_pushpull 1 1 1: push-pull output for single chip setup 0: open-drain for single or multi chip en_inj 18 0 unused reset 1 0 unused extrabits 15 0 unused"},{"location":"astropix3/configuration.html#analog-config","title":"Analog Config","text":"Field Name Bits Default Value Description DisHiDR 1 1 1: Amplifier high-gain mode 0: Amplifier bilinear gain mode q01 1 0 Biasblock enable (use default values) qon0 1 0 Biasblock enable (use default values) qon1 1 1 Biasblock enable (use default values) qon2 1 0 Biasblock enable (use default values) qon3 1 1 Biasblock enable (use default values) blres 6 0 Highpass filter bandwidth 0: low 63: high nu1 6 0 unused vn1 6 20 Amplifier input NMOS bias vnfb 6 1 Feedback current vnfoll 6 10 Amplifier operating point feedback nu5 6 0 unused nu6 6 0 unused nu7 6 0 unused nu8 6 0 unused vn2 6 0 Additional Amplifier input NMOS bias to increase maximum current vnfoll2 6 1 Low pass filter bandwidth 0: low 63: high vnbias 6 10 N-well bias vpload 6 5 Amplifier load current vnpmos 6 0 Amplifier input PMOS bias vncomp 6 2 Comparator bias current vpfoll 6 30 Ampout multiplexer current nu16 6 0 unused vprec 6 30 Levelshifter Pullup current vnrec 6 30 Levelshifter Receiver load current"},{"location":"astropix3/configuration.html#vdac-config","title":"VDAC Config","text":"Field Name Bits Default Value Description blpix: 10 568 Comparator baseline voltage thpix: 10 600 Comparator threshold voltage for NMOS Amplifier pixels vcasc2: 10 625 Amplifier load cascode voltage nu1: 10 512 unused thpmos: 10 682 Comparator threshold voltage for PMOS Amplifier pixels vinj: 10 0 Injection amplitude"},{"location":"astropix3/configuration.html#column-config","title":"Column Config","text":"<p>Each column incorporates a 38 bit shift register, and each columns are connected in series starting at column 0 to column 34.</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 1,  name: '', attr: \"InjRow\"},\n            {bits: 35,  name: '', attr: 'Pixel Comp Disable'},\n            {bits: 1,  name: '' , attr: 'InjCol'},\n            {bits: 1,  name: '', attr: 'AmpOut'},\n        ], config: { bits: 38},\n    }\n    </code>\n</pre> <p>For column n from 0 to 34:</p> <ul> <li>Bit 37: AmpOut Mux enable</li> <li>Bit 36: Enable Column for injection</li> <li>Bit 35-1: Enable Pixel comparators in column<ul> <li>Bit 35 is row 34</li> <li>Bit 1 is row 0</li> </ul> </li> <li>Bit 0: Enable Row n for Injection</li> </ul> <p>Warning</p> <p>Set AmpOut bit only in one column</p>"},{"location":"astropix3/dac.html","title":"DAC","text":""},{"location":"astropix3/dac.html#dac","title":"DAC","text":""},{"location":"astropix3/dac.html#current-dac","title":"Current DAC","text":"<p>Bias currents are generated by integrated 6 bit current DACs. The reference current is \\(\\sim 3 \\mu\\)A and the output current is set by the DACVAL (0-63). The individual current division ranges from 1 (0 - \\(3 \\mu\\)A) to 32768 (0 - 100 pA): $$ I_{bias} = 3 ~\\mu \\text{A} \\dfrac{\\text{DACVAL}}{63} \\text{DIVIDER} $$</p>"},{"location":"astropix3/dac.html#voltage-dac","title":"Voltage DAC","text":"<p>DNL and INL of integrated 10b R2R voltage dac</p> <p>AstroPix features integrated 10 bit R2R Voltage DACs to internally generate the comparator threshold (Vth) and baseline (Bl), the cascode voltage (Vcasc2).</p> <p>The reference voltage is vdda!, therefore the output voltage is set by the DACVAL (0-1023): $$ V_{out} = V_{vdda!} \\dfrac{\\text{DACVAL}}{1023} $$ If the external voltage card is used, the voltages will be forced to the values set by the external voltage card.</p>"},{"location":"astropix3/injection.html","title":"Injection","text":"<p>The injection can be controlled by:</p> <ul> <li>external voltage card generating the required injection pulses, in this case the digital injection (DigInj) input should be held at 0V</li> <li>digital injection to generate the pulses and the amplitude is set by the VDAC, in this case the injection pin (Inj)should float and the injection card should not be disconnected</li> </ul> <p>The simplified injection circuit shown below uses a voltage DAC and an NFET transistor controlled by a digital pulse.</p> <p></p> <p>Injection circuit, showing analog and digital injection input</p> <p>At the rising edge of the digital pulse, the left node of the injection capacitance \\(C_{\\text{inj}}\\) located in every pixel is quickly pulled to ground and the parasitic capacitance \\(C_\\text{par}\\) is discharged. This causes a charge \\(Q_{\\text{inj}}\\) being injected into the pixel n-well, if the according injection bits for row and column are enabled in the column configuration. The charge can be calculated by dividing the injection amplitude by the value of the injection capacitance, which has a value of around 7fF: $$ Q_{\\text{inj}}= \\dfrac{\\Delta V_{\\text{inj}}}{C_{\\text{inj}}} = \\dfrac{\\Delta V_{\\text{inj}}}{7\\text{fF}} $$</p> <p>The trailing edge of the injection pulse should be slow, this is ensured by the high output impedance of the voltage DAC.</p>"},{"location":"astropix3/pins.html","title":"Pins","text":"<p>Warning</p> <ul> <li>Unused inputs must be tied to ground unless otherwise specified.</li> <li>Unused outputs should be left unconnected.</li> <li>Unused bidirectional pins should be left unconnected.</li> </ul>"},{"location":"astropix3/pins.html#recommended-operating-parameters","title":"Recommended Operating Parameters","text":""},{"location":"astropix3/pins.html#supply-voltages","title":"Supply Voltages","text":"Parameter Min Typ Max Typ. Current Comment vdda! 1.62 V 1.8 V 1.98 V 1 mA All pads internally connected - add decoupling on each pad if possible vdd! 1.62 V 1.8 V 1.98 V 5 mA All pads internally connected - add decoupling on each pad if possible vssa! 1.1 V 1.2 V 1.98 V 1 mA All pads internally connected - add decoupling on each pad if possible vminuspix 0 V 0.7 V 1.98 V &lt; 100 uA Voltage regulator must be able to sink current HV 0 V -150 V -350 V &lt; 100 nA All pads internally connected - Negative Bias for Pixel Sensors <p>Warning</p> <p>The low voltage supplies vdda!, vdd! and vssa! should be turned on at the same time, otherwise the chip can be damaged due to high currents caused by forward biased diodes.</p>"},{"location":"astropix3/pins.html#lvds-receiver","title":"LVDS Receiver","text":"Parameter Min Typ Max Comment Common mode voltage 0.8 V 1.2V Differential amplitude 0.2 V 0.4 V Input capacitance ~3 pF"},{"location":"astropix3/pins.html#pins","title":"Pins","text":"<p>Note</p> <p>Pins starting with B are located at the bottom, L on the left and R on the right side of the chip</p> Pin Name Supply TYPE Description B1 sub! HV Power HV substrate Bias B2 sub! HV Power HV substrate Bias B3 sub! HV Power HV substrate Bias B4 sub! HV Power HV substrate Bias B5 subpixels float Power B6 vssaPmos! 1.2 V Power PMOS Amplifier supply for Col0-2 pixels B7 vssaPmos! 1.2 V Power PMOS Amplifier supply for Col0-2 pixels B8 vdda! 1.8 V Power B9 gnda! Power B10 vdda! 1.8 V Power B11 gnda! Power B12 vssa! 1.2 V Power B13 vssa! 1.2 V Power B14 vdda! 1.8 V Power B15 gnda! Power B16 vdda! 1.8 V Power B17 gnda! Power B18 vssa! 1.2 V Power B19 vssa! 1.2 V Power B20 vdda! 1.8 V Power B21 gnda! Power B22 vdda! 1.8 V Power B23 gnda! Power B24 vssa! 1.2 V Power B25 vssa! 1.2 V Power B26 sample_clock_p Input LVDS &lt;200 MHz Clock for ToT counter  (Connect to gnd! if Single ended clock is used) - P/N can be swapped B27 sample_clock_n Input LVDS &lt;200 MHz Clock for ToT counter  (Connect to vdd! if Single ended clock is used) - P/N can be swapped B28 vdd! 1.8 V Power B29 gnd! Power B30 interrupt Output (Open-Drain/pushpull see interrupt_pushpull config bit) Active low status signal (0: data to read out 1: no data to read out) - Needs 10 kOhm pullup to vdd! in Open-Drain mode B31 res_n Input Active low global reset B32 timestamp_clk Input Single ended 2.5 MHz ToA clock B33 hold Input Active high hold pauses sending hit data via SPI B34 sr_CK1 Input SPI Fallback: Clock1 for Chip Configuration B35 sr_CK2 Input SPI Fallback: Clock2 for Chip Configuration B36 sr_LOAD Input SPI Fallback: Load for Chip Configuration B37 sr_SIN Input SPI Fallback: In for Chip Configuration B38 sr_RB Input SPI Fallback: Readback for Chip Configuration B39 sr_SOUT Output SPI Fallback: Out for Chip Configuration B40 vdd! 1.8 V Power B41 gnd! Power B42 nc B43 nc B44 vssa! 1.2 V Power B45 vssa! 1.2 V Power B46 vdda! 1.8 V Power B47 vdda! 1.8 V Power B48 gnda! Power B49 gnda! Power B50 VPBias BiDir Reference current B51 VN BiDir NMOS Amplifier current B52 blpix BiDir Comparator baseline voltage B53 VPLoad BiDir Amplifier load current B54 gnda! Power B55 vdda! 1.8 V Power B56 Inj BiDir Analog Injection - should float if DigInj Pin 84 is used B57 gnda! Power B58 ThPix BiDir Comparator threshold voltage for NMOS Amplifier pixels B59 vminuspix 0.9 V Power Level shifter low level B60 gnda! Power B61 vdda! 1.8 V Power B62 ampout Output Source Follower to buffer signal from analog multiplexer, needs external load resistor 2 kOhm to gnda! B63 Qdac&lt;0&gt; Output Config bit to check configuration B64 Qdac&lt;1&gt; Output Config bit to check configuration B65 vssa! 1.2 V Power B66 vdda! 1.8 V Power B67 gnda! Power B68 Vtemp0 Output Analog temperature sensor1 B69 Vtemp1 Output Analog temperature sensor2 B70 Vcasc2! BiDir Load cascode voltage B71 VNPMOS BiDir PMOS Amplifier current B72 vdda! 1.8 V Power B73 gnda! Power B74 Vtemp2 Output Analog temperature sensor3 B75 Vtemp3 Output Analog temperature sensor4 B76 VCasc BiDir Amplifier input cascode voltage B77 ThPMOS BiDir Comparator threshold voltage for PMOS Amplifier pixels B78 vssa! 1.2 V Power B79 vdda! 1.8 V Power B80 gnda! Power B81 vssa! 1.2 V Power B82 vdda! 1.8 V Power B83 gnda! Power B84 DigInj Input Digital injection - should be held at 0V if Inj Pin 56 is used B85 vdd! 1.8 V Power B86 gnd! Power B87 ring4 B88 ring3 B89 ring2 B90 ring1 B91 sub! HV Power B92 sub! HV Power B93 sub! HV Power B94 sub! HV Power L1 SPI_left_MISO1 Output SPI Peripheral MISO1 L2 SPI_left_MISO0 Output SPI Peripheral MISO0 L3 SPI_left_MOSI Input SPI Peripheral MOSI L4 SPI_left_CLK Input SPI Clock input L5 SPI_left_CSN Input SPI Chip Select (active-low) input L6 sample_clock_left Output Single Ended ToT clock input R1 sample_clock_right Output Single Ended ToT clock output R2 SPI_right_CSN Output SPI Chip Select (active-low) output R3 SPI_right_CLK Output SPI Clock output R4 SPI_right_MOSI Output SPI Sender MOSI R5 SPI_right_MISO0 Input SPI Sender MISO0 R6 SPI_right_MISO1 Input SPI Sender MISO1"},{"location":"astropix3/pixelelectronics.html","title":"Pixel Electronics","text":""},{"location":"astropix3/pixelelectronics.html#pixel-electronics","title":"Pixel Electronics","text":""},{"location":"astropix3/pixelelectronics.html#csa-and-bandpass-filter","title":"CSA and Bandpass Filter","text":"<p>A simplified schematic of the pixel electronics is shown below:</p> <p></p> <p>Reverse biased sensor diode formed deep n-well and p-substrate, cascoded charge sensitive amplifier (CSA) and bandpass filter</p> <p>The sensing element is the pn-diode formed by the p-substrate and the deep n-well of the pixel. By applying a high reverse bias, a thick depletion region is created. Electrons generated by charged particles or photons in the depletion region are quickly transported to the collection n-well by drift, due to the strong electric field. A charge sensitive amplifier (CSA) is capacitively coupled to the collection n-well, it is implemented as a cascode amplifier with a cascode load and an NFET input device. The feedback capacitance of around 500 aF is formed by the parasitic drain junction capacitance of the load cascode PFET. A voltage signal is produced dependent on the input charge and this capacitance. Assuming that the amplifier has a high open loop gain \\(A_{0}\\) with \\(A_{O} C_{fb} &gt;&gt; C_{det}\\) this can be simplified to: $$ v_{out} \\approx \\dfrac{Q}{C_{fb}} $$ A second, much larger 15 fF feedback capacitance C1 is connected from the amplifier input to the voltage node between the load transistors. If the cascode transistor is in saturation, the impedance from the output to this node is high, but if there is a large input signal, the cascoded transistor goes into the linear region and there is a low impedance path from the output to this node. Therefore, for a large input signal the two capacitors appear to be in parallel resulting in a reduced closed-loop gain of: $$ v_{out} \\approx \\dfrac{Q}{C_{fb}+C_{fb2}} $$ The feedback capacitance is continuously discharged by a constant current source VNFB, which results in a linear decay of the output pulse. The amplifiers input DC operating point is set by the source-follower SF1. The second source-follower SF2 acts as a low pass filter. Due to its non-linearity, the rising edge has a fast rise time, but the falling edge because the load current source INFOLL2 is biased with a low current. A higher current increases the low pass filter bandwidth, resulting in a steeper slope i.e. shorter time-over-threshold (ToT) but also higher noise. From the output of SF2 the signal is capacitively coupled through a Metal-Insulator-Metal capacitor to AmpOutAC. The DC level is set by the voltage DAC blpix, which is connected to the signal though a small current source, acting as a high pass filter together with the coupling capacitance.</p>"},{"location":"astropix3/pixelelectronics.html#comparator-and-level-shifter","title":"Comparator and Level shifter","text":"<p>The signal path from the comparator input to the receiver output is shown below: </p> <p>CMOS comparator and Level shifter</p> <p>The comparator is a two stage amplifier with the first stage being a NFET differential amplifier with a PFET current source load and the second stage being a common-source amplifier to increase the gain. The analog voltage pulse goes into the comparator and gets compared to the threshold voltage Vth. The comparator bias current is set by the current digital-to-analog converter (DAC) VNCOMP. The output is a positive voltage pulse with Vlow 0V and VHigh 1.8V. Due to mismatch, the differential amplifier in the comparator is not totally symmetric. This results in a shift of the effective threshold to the value set by Vth. A compensation mechanism is implemented since AstroPix4, consisting of a 3bit current DAC which can be tuned to make the tail currents in the differential stage equal. The following stage is an open drain NFET, pulled up by the current source VPREC. This NFET converts the positive pulse to a negative pulse. The source of the NFET is connected to Vminuspix (normally 0.7 - 1V), which reduces the signal amplitude from 1.8V to 0.8 - 1.1V. A higher signal amplitude, i.e. a lower value of vminuspix reduces the propagation delay but also increases EMI at the same time. In the hit buffer of every pixel, the signal is converted back to the full amplitude by a PFET common-source amplifier. The output signal is a positive pulse with a fast rise time and a fall time which is determined by the discharge current VNREC.</p>"},{"location":"astropix3/readout.html","title":"Matrix Readout","text":""},{"location":"astropix3/readout.html#columnrow-hit-buffer","title":"Column/Row Hit Buffer","text":"<p>Hitbuffer showing ToA and ToT capturing, reset after read and hold masking</p> <p>The above circuit is implemented for every row and column. An incoming active low hit signal enables the clockgate of the ToT counter, starting the ToT measurement and latching the ToA timestamp. At the same time, the negative edge flipflop on top is triggered, activating the interrupt and deactivating the clock gate of the ToT counter. At the trailing edge of the hit pulse, a positive edge flipflop is triggered, signalizing to the readout state machine, that there is a hit available for readout. If hold is active this hit flag is masked.</p> <p>As soon as the SPI clock is toggled by the DAQ, the readout state machine starts to transfer the hits from the hit buffer to the SPI Interface. When this process is completed, the flipflops are reset and ready for the next hit.</p>"},{"location":"astropix3/spi.html","title":"SPI Interface","text":""},{"location":"astropix3/spi.html#spi-daisychain-interface","title":"SPI Daisychain Interface","text":""},{"location":"astropix3/spi.html#controlling-fe","title":"Controlling FE","text":"<p>AstroPix receives commands via the MOSI line, using the following 8-bit format:</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 5,  name: 'Chip Address (5b)', type: 4},\n            {bits: 3,  name: 'Command (3b)', type: 3},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre> <p>All valid commands are summarized in the table below:</p> BIT Field Description [4:0] Address 0x00 -  0x14 : Single addresses0x15 - 0x1F : Reserved0x1D: Invalid0x1E: Broadcast [7:5] Command 0x01 - NOCMD / IDLE0x02 - Routing: dispatch0x03 - Shift Register Config addresses <p>The IDLE byte represents no specific command and uses an invalid address: 0x1D for the address and 0x1 for IDLE, resulting in 0x3D.</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 5,  name: '0x1D', type: 4, attr: \"Address\"},\n            {bits: 3,  name: '0x1', type: 3, attr: \"Command\"},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre>"},{"location":"astropix3/spi.html#commands","title":"Commands","text":"COMMAND NAME LENGTH DESCRIPTION 0x01 NOCMD 1 Byte No Operation 0x02 Address Config 1 Byte Sets the chip address. The chip forwards the command to the next chip with Address = Address + 1.To configure addresses, start with chip \"00\" by sending 0x40, then send IDLE bytes to keep the clock active and propagate the address down the chain. 0x03 Shift Register Config N Bytes Uses the entire SPI frame for shift register configuration. SPI Chip Select must be toggled to send a new command."},{"location":"astropix3/spi.html#shift-register-io-and-spi-command","title":"Shift Register I/O and SPI Command","text":"<p>The shift register interface exposes two clocks, a serial input (SIN), and a load signal to load bits into the registers. Each bit on the SIN line is clocked through the shift register by toggling Clock 1 and Clock 2 separately. The diagram below illustrates a 3-bit register configuration:</p> <pre>    <code>\n    { signal : [\n        {name: 'Ck1',    wave: '0.10..10..10...'},\n        {name: 'Ck2',     wave: '0...10..10..10.'},\n        {name: 'SIN',     wave: 'x5..x5..x5..x..', data: ['Bit 0','Bit 1', 'Bit 2']},\n        {name: 'Load',   wave: '0............10'},\n    ], config:{hscale: 2}\n}\n    </code>\n</pre> <p>SPI commands generate this sequence as follows:</p> <ul> <li>The first byte contains the 0x3 command and the target chip or broadcast ID</li> <li>Each subsequent byte shifts a 0 or 1 into the shift register. The LSB of each byte is used for Serial In (<code>8'bxxxxxxx1</code> or <code>8'bxxxxxxx0</code>)</li> <li>At the end of the sequence, send a byte with bit[1] = 1 to generate the Load signal</li> <li>When the frame ends, the Load signal returns to 0</li> </ul>"},{"location":"astropix3/spi.html#reading-from-the-front-end-fe","title":"Reading from the Front-End (FE)","text":"<p>The APS-to-FE path differs from the FE-to-APS path, as it does not process commands. Its sole function is to forward packets down the chain and arbitrate between forwarded packets and those generated by the local readout.</p> <p>The data format on this path uses a header that includes the Chip ID and a length field, allowing the Arbiter to transmit complete frames without splitting them.</p>"},{"location":"astropix3/spi.html#hit-packet","title":"Hit Packet","text":"<p>A single hit generates two data frames: one for the row and one for the column. Because rows and columns are logically OR'd, two hits in the same column but different rows occurring simultaneously will produce only one column frame, but two row frames.</p> <p>Each frame consists of 5 bytes:</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 1,  name: 'Header', type: 2},\n            {bits: 1,  name: 'Hit Location', type: 3},\n            {bits: 1,  name: 'ToA Timestamp', type: 4},\n            {bits: 1,  name: 'ToT MSB', type: 5},\n            {bits: 1,  name: 'ToT LSB', type: 5},\n        ], config:{bits: 5, vflip: true}\n    }\n    </code>\n</pre>"},{"location":"astropix3/spi.html#header-byte","title":"Header Byte","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 3,  name: 'Payload (3b)', type: 2},\n            {bits: 5,  name: 'Chip Address (5b)', type: 2},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre> <ul> <li>Chip address is set by the routing byte</li> <li>Payload length indicates the number of bytes following the header</li> </ul>"},{"location":"astropix3/spi.html#hit-location-byte","title":"Hit Location Byte","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 6,  name: 'Row/Col Number', type: 3},\n            {bits: 1,  name: 'Reserved', type: 3},\n            {bits: 1,  name: '0:Row 1:Col', type: 3},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre> <ul> <li>MSB is for Row/Column identification<ul> <li>1: Column</li> <li>0: Row</li> </ul> </li> <li>Lower 6 bits specify the row or column address</li> </ul>"},{"location":"astropix3/spi.html#readout-procedure","title":"Readout procedure","text":"<p>Note</p> <p>If the chip is not configured and the SPI clock is toggled, you will likely see the no data case, where the chip responds with IDLE bytes. In some cases, you may also receive data generated by noise hits, unless hold is active. If you do not receive any data from the chip, check the physical SPI connection.</p>"},{"location":"astropix3/spi.html#readout-sequence","title":"Readout Sequence","text":"<ul> <li>Activate the Timestamp Clock and ToT clocks.</li> <li>Send the Routing Byte through the daisy-chain to assign chip IDs</li> <li>Send the Shift Register configuration command to configure the chips</li> <li>Wait for the interrupt falling edge, with the SPI clock deactivated</li> <li>When the interrupt is asserted, start the SPI clock to send dummy bytes (e.g., IDLE 0x3D) to initiate readout</li> <li>Continue sending dummy bytes until the interrupt is deasserted and no packets are detected for approximately 40 bytes</li> <li>Deactivate SPI clock again to save power</li> </ul>"},{"location":"astropix3/spi.html#data-available-for-readout","title":"Data available for readout","text":"<pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|..............................'},\n        {name: 'Interrupt',   wave: 'x1...|.0............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...4...4...4...4...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'HEADER Bit 0,2,4,6', 'Hit Location Bit 0,2,4,6', 'ToA Bit 0,2,4,6', 'ToT Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...4...4...4...4...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'HEADER Bit 1,3,5,7', 'Hit Location Bit 1,3,5,7', 'ToA Bit 1,3,5,7','ToT Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix3/spi.html#no-data-available","title":"No data available","text":"<p>This timing diagram shows the case when hold is low and interrupt is inactive, the chip returns only IDLE bytes because there is no hit data.</p> <pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|..............................'},\n        {name: 'Interrupt',   wave: 'x1...|..............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...3...3...3...3...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...3...3...3...3...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix3/spi.html#hold-active","title":"Hold active","text":"<p>This timing diagram shows the case when hold is active and interrupt is active, the chip returns only IDLE bytes instead of sending out hit data.</p> <pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|...1..........................'},\n        {name: 'Interrupt',   wave: 'x1...|.0............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...3...3...3...3...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...3...3...3...3...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix3/spi.html#readout-rate-considerations","title":"Readout Rate Considerations","text":"<p>To select a safe minimum SPI clock frequency, both the expected hit volume and the maximum acceptable readout latency must be considered. The formulas below give minimum values, include an appropriate safety margin when choosing the operating point. Note that the ToA timestamp is only 8 bits wide and the daisy-chain arbiter does not fully prioritize forwarded data; both factors increase the required SPI throughput.</p>"},{"location":"astropix3/spi.html#minimum-data-rate","title":"Minimum Data Rate","text":"<p>Assuming a maximum hit rate HR, the peak data rate  for a row of n chips is $$ \\text{DR} = n \\cdot \\textnormal{HR} \\cdot 2 \\cdot 5 ~\\text{Byte} $$</p> <p>Assuming n = 20 and a maximum hit rate HR of 10 Hz/sensor, the data rate DR is 16 Kbit/s, requiring a minimum SPI clock frequency of 8 kHz.</p>"},{"location":"astropix3/spi.html#latency-requirements","title":"Latency Requirements","text":"<p>Let n be the number of chips in a row and RR the readout rate (RR is twice the SPI clock frequency, as there are 2 MISO lines). The minimum readout latency for a hit originating at the last chip in the row, when only that chip has a hit, is $$ t_{\\text{lat, single hit}} = \\dfrac{2\\cdot 5 ~\\text{Byte} + 2 ~\\text{Byte}\\cdot (n-1)}{\\text{RR}} $$</p> <p>If every chip in the row has a stored hit, the minimum latency becomes $$ t_{\\text{lat, all hits}} = \\dfrac{2\\cdot 5 ~\\text{Byte} \\cdot n}{\\text{RR}} $$</p> <p>This latency must be shorter than the wrap time of the 8-bit time-of-arrival counter $$ t_{\\text{lat}} &lt; 2^8 ~T_{\\text{ckts}} $$ where \\(T_\\textnormal{ckts}\\) is the timestamp clock period.</p> <p>Using \\(T_\\textnormal{ckts}\\) = 1/2 MHz and n = 20 gives the following practical numbers: the single-hit case requires DR ~ 1.4 Mbit/s (SPI clock = 0.7 MHz). In the case where every chip has a stored hit, DR ~ 6.4 Mbit/s (SPI clock = 3.2 MHz).</p> <p>If a slower timestamp clock can be tolerated, the required SPI clock frequency can be reduced accordingly.</p>"},{"location":"astropix3/configuration/format_col_config.html","title":"Format col config","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 1,  name: '', attr: \"InjRow\"},\n            {bits: 35,  name: '', attr: 'Pixel Comp Disable'},\n            {bits: 1,  name: '' , attr: 'InjCol'},\n            {bits: 1,  name: '', attr: 'AmpOut'},\n        ], config: { bits: 38},\n    }\n    </code>\n</pre>"},{"location":"astropix3/spi/format_idle.html","title":"Format idle","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 5,  name: '0x1D', type: 4, attr: \"Address\"},\n            {bits: 3,  name: '0x1', type: 3, attr: \"Command\"},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre>"},{"location":"astropix3/spi/format_packet.html","title":"Format packet","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 5,  name: 'Chip Address (5b)', type: 4},\n            {bits: 3,  name: 'Command (3b)', type: 3},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre>"},{"location":"astropix3/spi/format_packet_hit.html","title":"Format packet hit","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 1,  name: 'Header', type: 2},\n            {bits: 1,  name: 'Hit Location', type: 3},\n            {bits: 1,  name: 'ToA Timestamp', type: 4},\n            {bits: 1,  name: 'ToT MSB', type: 5},\n            {bits: 1,  name: 'ToT LSB', type: 5},\n        ], config:{bits: 5, vflip: true}\n    }\n    </code>\n</pre>"},{"location":"astropix3/spi/format_packet_hit_location.html","title":"Format packet hit location","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 6,  name: 'Row/Col Number', type: 3},\n            {bits: 1,  name: 'Reserved', type: 3},\n            {bits: 1,  name: '0:Row 1:Col', type: 3},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre>"},{"location":"astropix3/spi/format_packet_read.html","title":"Format packet read","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 3,  name: 'Payload (3b)', type: 2},\n            {bits: 5,  name: 'Chip Address (5b)', type: 2},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre>"},{"location":"astropix3/spi/format_sr.html","title":"Format sr","text":"<pre>    <code>\n    { signal : [\n        {name: 'Ck1',    wave: '0.10..10..10...'},\n        {name: 'Ck2',     wave: '0...10..10..10.'},\n        {name: 'SIN',     wave: 'x5..x5..x5..x..', data: ['Bit 0','Bit 1', 'Bit 2']},\n        {name: 'Load',   wave: '0............10'},\n    ], config:{hscale: 2}\n}\n    </code>\n</pre>"},{"location":"astropix3/spi/timing_spi.html","title":"Timing spi","text":"<pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|..............................'},\n        {name: 'Interrupt',   wave: 'x1...|.0............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...4...4...4...4...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'HEADER Bit 0,2,4,6', 'Hit Location Bit 0,2,4,6', 'ToA Bit 0,2,4,6', 'ToT Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...4...4...4...4...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'HEADER Bit 1,3,5,7', 'Hit Location Bit 1,3,5,7', 'ToA Bit 1,3,5,7','ToT Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix3/spi/timing_spi_hold.html","title":"Timing spi hold","text":"<pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|...1..........................'},\n        {name: 'Interrupt',   wave: 'x1...|.0............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...3...3...3...3...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...3...3...3...3...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix3/spi/timing_spi_no_data.html","title":"Timing spi no data","text":"<pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|..............................'},\n        {name: 'Interrupt',   wave: 'x1...|..............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...3...3...3...3...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...3...3...3...3...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix4/index.html","title":"Index","text":""},{"location":"astropix5/index.html","title":"Index","text":""},{"location":"astropix5/dac.html","title":"DAC","text":""},{"location":"astropix5/dac.html#dac","title":"DAC","text":""},{"location":"astropix5/dac.html#current-dac","title":"Current DAC","text":"<p>Bias currents are generated by integrated 6 bit current DACs. The reference current is \\(\\sim 3 \\mu\\)A and the output current is set by the DACVAL (0-63). The individual current division ranges from 1 (0 - \\(3 \\mu\\)A) to 32768 (0 - 100 pA): $$ I_{bias} = 3 ~\\mu \\text{A} \\dfrac{\\text{DACVAL}}{63} \\text{DIVIDER} $$</p>"},{"location":"astropix5/dac.html#voltage-dac","title":"Voltage DAC","text":"<p>DNL and INL of integrated 10b R2R voltage dac</p> <p>AstroPix features integrated 10 bit R2R Voltage DACs to internally generate the comparator threshold (Vth) and baseline (Bl), the cascode voltage (Vcasc2).</p> <p>The reference voltage is vdda!, therefore the output voltage is set by the DACVAL (0-1023): $$ V_{out} = V_{vdda!} \\dfrac{\\text{DACVAL}}{1023} $$ If the external voltage card is used, the voltages will be forced to the values set by the external voltage card.</p>"},{"location":"astropix5/injection.html","title":"Injection","text":"<p>The injection can be controlled by:</p> <ul> <li>external voltage card generating the required injection pulses, in this case the digital injection (DigInj) input should be held at 0V</li> <li>digital injection to generate the pulses and the amplitude is set by the VDAC, in this case the injection pin (Inj)should float and the injection card should not be disconnected</li> </ul> <p>The simplified injection circuit shown below uses a voltage DAC and an NFET transistor controlled by a digital pulse.</p> <p></p> <p>Injection circuit, showing analog and digital injection input</p> <p>At the rising edge of the digital pulse, the left node of the injection capacitance \\(C_{\\text{inj}}\\) located in every pixel is quickly pulled to ground and the parasitic capacitance \\(C_\\text{par}\\) is discharged. This causes a charge \\(Q_{\\text{inj}}\\) being injected into the pixel n-well, if the according injection bits for row and column are enabled in the column configuration. The charge can be calculated by dividing the injection amplitude by the value of the injection capacitance, which has a value of around 7fF: $$ Q_{\\text{inj}}= \\dfrac{\\Delta V_{\\text{inj}}}{C_{\\text{inj}}} = \\dfrac{\\Delta V_{\\text{inj}}}{7\\text{fF}} $$</p> <p>The trailing edge of the injection pulse should be slow, this is ensured by the high output impedance of the voltage DAC.</p>"},{"location":"astropix5/pins.html","title":"Pins","text":"<p>Warning</p> <ul> <li>Unused inputs must be tied to ground unless otherwise specified.</li> <li>Unused outputs should be left unconnected.</li> <li>Unused bidirectional pins should be left unconnected.</li> </ul>"},{"location":"astropix5/pins.html#recommended-operating-parameters","title":"Recommended Operating Parameters","text":""},{"location":"astropix5/pins.html#supply-voltages","title":"Supply Voltages","text":"Parameter Min Typ Max Typ. Current Comment vdda! 1.62 V 1.8 V 1.98 V 1 mA All pads internally connected - add decoupling on each pad if possible vdd! 1.62 V 1.8 V 1.98 V 5 mA All pads internally connected - add decoupling on each pad if possible vssa! 1.1 V 1.2 V 1.98 V 4 mA All pads internally connected - add decoupling on each pad if possible vminuspix 0 V 1 V 1.98 V &lt; 100 uA Generated by internal regulator -  disable through configbit VGateComp 1.8 2.1 V 2.2 V &lt; 1 uA Generated by internal regulator -  disable through configbit HV 0 V -150 V -350 V &lt; 100 nA All pads internally connected - Negative Bias for Pixel Sensors <p>Warning</p> <p>The low voltage supplies vdda!, vdd! and vssa! should be turned on at the same time, otherwise the chip can be damaged due to high currents caused by forward biased diodes.</p>"},{"location":"astropix5/pins.html#lvds-receiver","title":"LVDS Receiver","text":"Parameter Min Typ Max Conditions Common mode voltage 0.8 V 1.2V Differential amplitude 0.2 V 0.4 V Input capacitance ~3 pF"},{"location":"astropix5/pins.html#lvds-driver","title":"LVDS Driver","text":"Parameter Min Typ Max Conditions Common mode voltage 0.8 V 0.9V 1.1 V Differential amplitude 0.2 V Differential termination $R_T = 100~\\Omega $ Wake up time after Enable 100 ns"},{"location":"astropix5/pins.html#pins","title":"Pins","text":"<p>Note</p> <p>Pins starting with B are located at the bottom, L on the left and R on the right side of the chip</p> Pin Name Supply TYPE Description B1 vdd! 1.8 V Power B2 gnd! Power B3 chipring Power Guardring - Don't connect B4 sub! HV Power HV substrate Bias B5 sub! HV Power HV substrate Bias B6 dnring Power Guardring - Don't connect but add option to connect to vdda! B7 pring_pixel Power Guardring - Don't connect B8 gnd! Power B9 gnd! Power B10 vdd! 1.8 V Power B11 vdd! 1.8 V Power B12 gnda! Power B13 vdda! 1.8 V Power B14 gnda! Power B15 vdda! 1.8 V Power B16 gnda! Power B17 vdda! 1.8 V Power B18 vssa! 1.2 V Power B19 vssa! 1.2 V Power B20 VGateComp! 1.8 - 2.1 V Power NMOS Comparator Gate voltage B21 SR_out_OD Output (Open-Drain) Shift Register SOut B22 SR_out_CK1 Output (Open-Drain) Shift Register Ck1 B23 pll_clk Output PLL debug out B24 Enable_SPI_diff Input Enable differential SPI Interface B25 vdd! 1.8 V Power B26 gnd! Power B27 SPI_MISO1_P Output (LVDS) SPI Peripheral MISO1 B28 SPI_MISO1_N Output (LVDS) SPI Peripheral MISO1 B29 SPI_MISO0_P Output (LVDS) SPI Peripheral MISO0 B30 SPI_MISO0_N Output (LVDS) SPI Peripheral MISO0 B31 gnd! Power B32 SPI_MOSI_P Input (LVDS) SPI Peripheral MOSI B33 SPI_MOSI_N Input (LVDS) SPI Peripheral MOSI B34 SPI_CLK_P Input (LVDS) SPI Clock input B35 SPI_CLK_N Input (LVDS) SPI Clock input B36 SPI_CSN_P Input (LVDS) SPI Chip Select (active-low) input B37 SPI_CSN_N Input (LVDS) SPI Chip Select (active-low) input B38 gnd! Power B39 HBOut Output Hitbus Out, needs external load resistor 2 kOhm to gnd! B40 timestamp_clk Input Single ended 2.5 MHz ToA clock B41 Clk20_Ext_P Input (LVDS) External 20 MHz Clk (Connect to vdd! if unused) B42 Clk20_Ext_N Input (LVDS) External 20 MHz Clk (Connect to gnd! if unused) B43 vdd! 1.8 V Power B44 gnd! Power B45 interrupt Output (Open-Drain/pushpull see interrupt_pushpull config bit) Active low status signal (0: data to read out 1: no data to read out) - Needs 10 kOhm pullup to vdd! in Open-Drain mode B46 res_n Input Active low global reset B47 syncres Input Active high synchronous timestamp counter reset B48 hold Input Active high hold pauses sending hit data via SPI B49 SR_ck1 Input SPI Fallback: Clock1 for Chip Configuration B50 SR_ck2 Input SPI Fallback: Clock2 for Chip Configuration B51 SR_load Input SPI Fallback: Load for Chip Configuration B52 SR_sin Input SPI Fallback: In for Chip Configuration B53 SR_rb Input SPI Fallback: Readback for Chip Configuration B54 SR_ldtdac Input SPI Fallback:  Load for TDAC Configuration B55 SR_ldpatgen Input SPI Fallback:  Load for Pattern Generator Configuration B56 SR_sout Output SPI Fallback: Out for Chip Configuration B57 vdd! 1.8 V Power B58 gnd! Power B59 vdda! 1.8 V Power B60 gnda! Power B61 vssa! 1.2 V Power B62 vssa! 1.2 V Power B63 vdda! 1.8 V Power B64 gnda! Power B65 VPBias! BiDir Reference current B66 pamp BiDir Amplifier current B67 blpix BiDir Comparator baseline voltage B68 pload BiDir Amplifier load current B69 gnda! Power B70 vdda! 1.8 V Power B71 Inj Input Analog Injection - should be held at 0V if DigInj Pin 92 is used B72 gnda! Power B73 ThPix BiDir Comparator threshold voltage B74 gnda! Power B75 vdda! 1.8 V Power B76 ampout Output Source Follower to buffer signal from analog multiplexer, needs external load resistor 2 kOhm to gnda! B77 Qdac&lt;0&gt; Output Config bit to check configuration B78 Qdac&lt;1&gt; Output Config bit to check configuration B79 vssa! 1.2 V Power B80 VCasc2! BiDir Load cascode voltage B81 vdda! 1.8 V Power B82 gnda! Power B83 Vtemp1 Output Temperature Sensor 1 Analog Out B84 Vtemp2 Output Temperature Sensor 2 Analog Out B85 cascpix BiDir Amplifier input cascode voltage B86 vssa! 1.2 V Power B87 vdda! 1.8 V Power B88 gnda! Power B89 vssa! 1.2 V Power B90 vdda! 1.8 V Power B91 gnda! Power B92 DigInj Input Digital injection - should be held at 0V if Inj Pin 71 is used B93 vdd! 1.8 V Power B94 gnd! Power B95 vminusref BiDir Vminus Reference Voltage B96 vminusout Output Vminus Regulator Output -  Connect to vminuspix Pin 97 B97 vminuspix 1 V Power Vminus B98 vdda! 1.8 V Power B99 gnda! Power B100 gnda! Power B101 vdda! 1.8 V Power B102 gnda! Power B103 vdda! 1.8 V Power B104 gnda! Power B105 vdda! 1.8 V Power B106 vssa! 1.2 V Power B107 vssa! 1.2 V Power B108 vdd! 1.8 V Power B109 gnd! Power L1 SPI_left_MISO1 Output SPI Peripheral MISO1 L2 SPI_left_MISO0 Output SPI Peripheral MISO0 L3 SPI_left_MOSI Input SPI Peripheral MOSI L4 SPI_left_CLK Input SPI Clock input L5 SPI_left_CSN Input SPI Chip Select (active-low) input L6 pring4 Output Guardring - Don't connect L7 pring3 Output Guardring - Don't connect L8 pring2 Output Guardring - Don't connect L9 pring1 Output Guardring - Don't connect L10 pring0 Output Guardring - Don't connect R1 SPI_right_CSN Output SPI Chip Select (active-low) output R2 SPI_right_CLK Output SPI Clock output R3 SPI_right_MOSI Output SPI Sender MOSI R4 SPI_right_MISO0 Input SPI Sender MISO0 R5 SPI_right_MISO1 Input SPI Sender MISO1"},{"location":"astropix5/pins.html#layout-gds","title":"Layout GDS","text":"<p>An encrypted zip file containing the GDS with chipedge and labeled Bondpads can be downloaded here. A recommended GDS viewer is KLayout (all platform support).</p>"},{"location":"astropix5/pixelelectronics.html","title":"Pixel Electronics","text":""},{"location":"astropix5/pixelelectronics.html#pixel-electronics","title":"Pixel Electronics","text":""},{"location":"astropix5/pixelelectronics.html#csa-and-bandpass-filter","title":"CSA and Bandpass Filter","text":"<p>A simplified schematic of the pixel electronics is shown below:</p> <p></p> <p>Reverse biased sensor diode formed deep n-well and p-substrate, cascoded charge sensitive amplifier (CSA) and bandpass filter</p> <p>The sensing element is the pn-diode formed by the p-substrate and the deep n-well of the pixel. By applying a high reverse bias, a thick depletion region is created. Electrons generated by charged particles or photons in the depletion region are quickly transported to the collection n-well by drift, due to the strong electric field. A charge sensitive amplifier (CSA) is capacitively coupled to the collection n-well, it is implemented as a cascode amplifier with a cascode load and an NFET input device. The feedback capacitance of around 500 aF is formed by the parasitic drain junction capacitance of the load cascode PFET. A voltage signal is produced dependent on the input charge and this capacitance. Assuming that the amplifier has a high open loop gain \\(A_{0}\\) with \\(A_{O} C_{fb} &gt;&gt; C_{det}\\) this can be simplified to: $$ v_{out} \\approx \\dfrac{Q}{C_{fb}} $$ A second, much larger 15 fF feedback capacitance C1 is connected from the amplifier input to the voltage node between the load transistors. If the cascode transistor is in saturation, the impedance from the output to this node is high, but if there is a large input signal, the cascoded transistor goes into the linear region and there is a low impedance path from the output to this node. Therefore, for a large input signal the two capacitors appear to be in parallel resulting in a reduced closed-loop gain of: $$ v_{out} \\approx \\dfrac{Q}{C_{fb}+C_{fb2}} $$ The feedback capacitance is continuously discharged by a constant current source VNFB, which results in a linear decay of the output pulse. The amplifiers input DC operating point is set by the source-follower SF1. The second source-follower SF2 acts as a low pass filter. Due to its non-linearity, the rising edge has a fast rise time, but the falling edge because the load current source INFOLL2 is biased with a low current. A higher current increases the low pass filter bandwidth, resulting in a steeper slope i.e. shorter time-over-threshold (ToT) but also higher noise. From the output of SF2 the signal is capacitively coupled through a Metal-Insulator-Metal capacitor to AmpOutAC. The DC level is set by the voltage DAC blpix, which is connected to the signal though a small current source, acting as a high pass filter together with the coupling capacitance.</p>"},{"location":"astropix5/pixelelectronics.html#dynamic-feedback","title":"Dynamic Feedback","text":""},{"location":"astropix5/pixelelectronics.html#comparator-flavours","title":"Comparator Flavours","text":""},{"location":"astropix5/plldll.html","title":"PLL and DLL","text":"<p>Note</p> <p>If the PLL is not used, the LVDS Receiver for the external clock must be enabled in the configuration and an appropriate clock must be provided for the chip to work</p> <p>External Clock: Clkmux 0, DisableLVDS 0, VNCp: x, VNVCO: 0 Internal Clock: Clkmux 1, DisableLVDS 1, VNCp: 10, VNVCO: 0</p>"},{"location":"astropix5/plldll.html#pll","title":"PLL","text":"<p>AstroPix5 features an integrated Second-Order Type-2 PLL used to generate a 20 MHz clock from an externally provided 2.5 MHz Reference Clock. $$ F_{\\text{OutClk}} = 8 F_{\\text{RefClk}} $$</p>"},{"location":"astropix5/plldll.html#block-diagram","title":"Block diagram","text":"<p>It is a single-ended design using TSPC logic in the high frequency parts to reduce the power consumption. The 9-stage current starved VCO is current-controlled through a V-I Converter, used to reduce the VCO Gain and effectively reducing phase noise. The coarse control current can be further controlled by VNVCO current.</p> <p></p> <p>Block Diagram of Second-Order Type-2 PLL to generate a x8 faster clock</p>"},{"location":"astropix5/plldll.html#configuration","title":"Configuration","text":"<p>To use the PLL clock, the clock multiplexer bit in the chip configuration has to be set to 1. The only current which needs to be configured for the PLL to work is the charge pump current set by VNCp, a lower value reduces phase noise but increase the lock time, which fortunately is not important in this application. A good starting point is a current of 2.5 \\(\\mu\\)A i.e. a VNCp setting of 10. VNVCO can be usually set to 0.</p>"},{"location":"astropix5/plldll.html#dll","title":"DLL","text":"<p>It also features an integrated DLL used to regulate the total delay line consisting of 16 delay elements to the reference clock period. The delay line is an exact replica of the delay line used in the per-Pixel TDCs, therefore allowing the regulation of the TDC delay.</p>"},{"location":"astropix5/plldll.html#block-diagram_1","title":"Block diagram","text":"<p>It is also a single-ended design including a startup controller to prevent harmonic lock and stuck state from being outside the lock-in range. The control bias voltage for the delay lines is replicated to not influence the filter pole and stability by the load capacitance of the circuit.</p> <p></p> <p>Block Diagram of the DLL with startup controller to control the total delay of the TDCs</p> <p>The delay of a single delay element can be calculated by: $$ T_{\\text{delaycell}} = \\dfrac{1}{F_{\\text{OutClk}} 16} $$</p> <p>This results in a delay of 3.125 ns for a single delay element at a clock speed of 20 MHz.</p>"},{"location":"astropix5/plldll.html#configuration_1","title":"Configuration","text":"<p>The only current which needs to be configured for the DLL to work is the charge pump current set by VNCp, which also used by the PLL.</p>"},{"location":"astropix5/readout.html","title":"Readout","text":""},{"location":"astropix5/readout.html#hitbuffer","title":"Hitbuffer","text":""},{"location":"astropix5/readout.html#eoc","title":"EoC","text":""},{"location":"astropix5/readout.html#tdc","title":"TDC","text":""},{"location":"astropix5/spi.html","title":"SPI Interface","text":""},{"location":"astropix5/spi.html#spi-daisychain-interface","title":"SPI Daisychain Interface","text":"<p>The AstroPix5 SPI Interface is an enhanced version of the SPI Interface of AstroPix3.</p> <p>The main differences are:</p> <ul> <li>One 8 Byte frame per hit instead of two 5 Byte frames</li> <li>Two new commands Heartbeat and ADC Readout</li> <li>All shift registers configurable via SPI</li> <li>Improved interrupt logic, monitoring also the chain FIFOs, making it unnecessary to toggle the SPI much longer after the interrupt de-assertion</li> </ul>"},{"location":"astropix5/spi.html#controlling-fe","title":"Controlling FE","text":"<p>AstroPix receives commands via the MOSI line, using the following 8-bit format:</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 5,  name: 'Chip Address (5b)', type: 4},\n            {bits: 3,  name: 'Command (3b)', type: 3},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre> <p>All valid commands are summarized in the table below:</p> BIT Field Description [4:0] Address 0x00 -  0x14 : Single addresses0x15 - 0x1F : Reserved0x1D: Invalid0x1E: Broadcast [7:5] Command 0x01 - NOCMD / IDLE0x02 - Routing: dispatch0x03 - Shift Register Config addresses <p>The IDLE byte represents no specific command and uses an invalid address: 0x1D for the address and 0x1 for IDLE, resulting in 0x3D.</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 5,  name: '0x1D', type: 4, attr: \"Address\"},\n            {bits: 3,  name: '0x1', type: 3, attr: \"Command\"},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre>"},{"location":"astropix5/spi.html#commands","title":"Commands","text":"COMMAND NAME LENGTH DESCRIPTION 0x01 NOCMD 1 Byte No Operation 0x02 Address Config 1 Byte Sets the chip address. The chip forwards the command to the next chip with Address = Address + 1.To configure addresses, start with chip \"00\" by sending 0x40, then send IDLE bytes to keep the clock active and propagate the address down the chain. 0x03 Shift Register Config N Bytes Uses the entire SPI frame for shift register configuration. SPI Chip Select must be toggled to send a new command. 0x04 Heartbeat 1 Byte Request Heartbeat Package from chip via Address or from all chips via Broadcast 0x1E 0x05 ADC Readout 1 Byte Request acquisition of 8 voltages (2 temperature sensors and 6 bias voltage) from on-chip ADC"},{"location":"astropix5/spi.html#shift-register-io-and-spi-command","title":"Shift Register I/O and SPI Command","text":"<p>The shift register interface exposes two clocks, a serial input (SIN), and a load signal to load bits into the registers. Each bit on the SIN line is clocked through the shift register by toggling Clock 1 and Clock 2 separately. The diagram below illustrates a 3-bit register configuration:</p> <pre>    <code>\n    { signal : [\n        {name: 'Ck1',    wave: '0.10..10..10...'},\n        {name: 'Ck2',     wave: '0...10..10..10.'},\n        {name: 'SIN',     wave: 'x5..x5..x5..x..', data: ['Bit 0','Bit 1', 'Bit 2']},\n        {name: 'Load',   wave: '0............10'},\n    ], config:{hscale: 2}\n}\n    </code>\n</pre> <p>SPI commands generate this sequence as follows:</p> <ul> <li>The first byte contains the 0x3 command and the target chip or broadcast ID</li> <li>Each subsequent byte shifts a 0 or 1 into the shift register. The LSB of each byte is used for Serial In (<code>8'bxxxxxxx1</code> or <code>8'bxxxxxxx0</code>)</li> <li>At the end of the sequence, send a byte with bit[1] = 1 to generate the required Load signal, in this case for the digital config</li> <li>When the frame ends, the Load signal returns to 0</li> </ul> <pre>    <code>\n    {\n        reg:[\n            {bits: 1,  name: 'SIN', type: 2},\n            {bits: 1,  name: 'Load DigConfig', type: 3},\n            {bits: 1,  name: 'Load ColConfig', type: 3},\n            {bits: 1,  name: 'Load TDAC', type: 3},\n            {bits: 1,  name: 'Load Pulsegen', type: 3},\n            {bits: 3,  name: 'Unused', type: 0},\n        ], config:{bits: 8, vflip: false}\n    }\n    </code>\n</pre>"},{"location":"astropix5/spi.html#reading-from-the-front-end-fe","title":"Reading from the Front-End (FE)","text":"<p>The APS-to-FE path differs from the FE-to-APS path, as it does not process commands. Its sole function is to forward packets down the chain and arbitrate between forwarded packets and those generated by the local readout.</p> <p>The data format on this path uses a header that includes the Chip ID and a length field, allowing the Arbiter to transmit complete frames without splitting them.</p>"},{"location":"astropix5/spi.html#hit-packet","title":"Hit Packet","text":"<p>A single hit generates a single data frames, which is different to the 2 row and column half hits generated by AstroPix3.</p> <p>Each frame consists of 7 bytes:</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 8,  name: 'Header', type: 2},\n            {bits: 5,  name: 'Row [4:0]', type: 3},\n            {bits: 5,  name: 'Col [4:0]', type: 3},\n            {bits: 18,  name: 'TS1 Neg, TS1 [16:0]', type: 4},\n            {bits: 5,  name: 'TS1 TDC', type: 4},\n            {bits: 18,  name: 'TS2 Neg, TS2 [16:0]', type: 5},\n            {bits: 5,  name: 'TS2 TDC', type: 5},\n        ], config:{bits: 64, vflip: true}\n    }\n    </code>\n</pre>"},{"location":"astropix5/spi.html#header-byte","title":"Header Byte","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 3,  name: 'Payload (3b)', type: 2},\n            {bits: 5,  name: 'Chip Address (5b)', type: 2},\n        ], config:{bits: 8}\n    }\n    </code>\n</pre> <ul> <li>Chip address is set by the routing byte</li> <li>Payload length indicates the number of bytes following the header</li> </ul>"},{"location":"astropix5/spi.html#hit-location","title":"Hit Location","text":"<p>The hit location is a 5 bit binary column and row address sent within the two first bytes after the header.</p>"},{"location":"astropix5/spi.html#adc-readout","title":"ADC Readout","text":"<p>The ADC readout command 0x5 is used to readout 8 voltages, including the 2 temperature sensors and 6 bias voltages (BL, Th, Vcasc2!, GateRef, vminus, Vinj). The chips needs a few milliseconds to acquire the voltages, but it asserts the interrupt when the acquisition is done.</p> <p>The ADC data is packed into two data frames. The first two Bytes of the first package are 0xFFFE and 0xFFFD for the second package. Therefore, they can also be distinguished from a normal data packet, as the pixel address is 63, 63 which does not correspond to an existing pixel.</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 8,  name: 'Header', type: 2},\n            {bits: 16,  name: '0xFFFE', type: 3},\n            {bits: 16,  name: 'Temp1', type: 4},\n            {bits: 16,  name: 'Temp2', type: 4},\n            {bits: 8,  name: 'BL', type: 4},\n\n        ], config:{bits: 64, vflip: true}\n    }\n    </code>\n</pre> <pre>    <code>\n    {\n        reg:[\n            {bits: 8,  name: 'Header', type: 2},\n            {bits: 16,  name: '0xFFFD', type: 3},\n            {bits: 8,  name: 'Th', type: 4},\n            {bits: 8,  name: 'Vcasc2', type: 4},\n            {bits: 8,  name: 'GateRef', type: 4},\n            {bits: 8,  name: 'Vminus', type: 4},\n            {bits: 8,  name: 'Vinj', type: 4},\n\n        ], config:{bits: 64, vflip: true}\n    }\n    </code>\n</pre>"},{"location":"astropix5/spi.html#heartbeat","title":"Heartbeat","text":"<p>The heartbeat command 0x4 can be used to get \u201esign of life\u201c and to check if a chip is configured. It can be broadcasted or sent to individual chips via their ID.</p> <p>The chip answers with a packet similar to the normal readout data frame. The first two bytes are 0xFFFF, then the 16 Extrabits from the configuration are sent non-inverted and inverted. The last Byte is the current count of the internal SEU counter. Similar to the ADC readout package, it can also be distinguished from a normal data packet, as the pixel address is 63, 63 which does not correspond to an existing pixel.</p> <pre>    <code>\n    {\n        reg:[\n            {bits: 8,  name: 'Header', type: 2},\n            {bits: 16,  name: '0xFFFF', type: 3},\n            {bits: 16,  name: 'Extrabits', type: 4},\n            {bits: 16,  name: 'ExtrabitsN', type: 4},\n            {bits: 8,  name: 'SEU Counter', type: 5},\n\n        ], config:{bits: 64, vflip: true}\n    }\n    </code>\n</pre>"},{"location":"astropix5/spi.html#readout-procedure","title":"Readout procedure","text":"<p>Note</p> <p>If the chip is not configured and the SPI clock is toggled, you will likely see the no data case, where the chip responds with IDLE bytes. In some cases, you may also receive data generated by noise hits, unless hold is active. If you do not receive any data from the chip, check the physical SPI connection.</p>"},{"location":"astropix5/spi.html#readout-sequence","title":"Readout Sequence","text":"<ul> <li>Activate the Timestamp Clock and if the integrated PLL is not used also the ToT clocks.</li> <li>Send the Routing Byte through the daisy-chain to assign chip IDs</li> <li>Send the Shift Register configuration command to configure the chips</li> <li>Wait for the interrupt falling edge, with the SPI clock deactivated</li> <li>When the interrupt is asserted, start the SPI clock to send dummy bytes (e.g., IDLE 0x3D) to initiate readout</li> <li>Continue sending dummy bytes until the interrupt is deasserted</li> <li>Deactivate SPI clock again to save power</li> </ul>"},{"location":"astropix5/spi.html#data-available-for-readout","title":"Data available for readout","text":"<pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|..............................'},\n        {name: 'Interrupt',   wave: 'x1...|.0............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...4...4...4...4...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'HEADER Bit 0,2,4,6', 'Hit Location Bit 0,2,4,6', 'ToA Bit 0,2,4,6', 'ToT Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...4...4...4...4...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'HEADER Bit 1,3,5,7', 'Hit Location Bit 1,3,5,7', 'ToA Bit 1,3,5,7','ToT Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix5/spi.html#no-data-available","title":"No data available","text":"<p>This timing diagram shows the case when hold is low and interrupt is inactive, the chip returns only IDLE bytes because there is no hit data.</p> <pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|..............................'},\n        {name: 'Interrupt',   wave: 'x1...|..............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...3...3...3...3...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...3...3...3...3...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix5/spi.html#hold-active","title":"Hold active","text":"<p>This timing diagram shows the case when hold is active and interrupt is active, the chip returns only IDLE bytes instead of sending out hit data.</p> <pre>    <code>\n    { signal : [\n        {name: 'ResetN',      wave: '10.1.|..............................'},\n        {name: 'hold',        wave: '0....|...1..........................'},\n        {name: 'Interrupt',   wave: 'x1...|.0............................'},\n        {},\n        {name: 'SPI CLK',     wave: '0....|......p.......................'},\n        {name: 'SPI MOSI',    wave: 'xxxxx|x.....2.......2.......2.......', data: ['IDLE 0x3D','IDLE 0x3D', 'IDLE 0x3D']},\n        {name: 'SPI CSN',     wave: '1....|...0..........................'},\n        {name: 'SPI MISO[0]', wave: 'z....|...1..3...3...3...3...3...3...', data: ['IDLE Bit 0,2,4,6','IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6', 'IDLE Bit 0,2,4,6']},\n        {name: 'SPI MISO[1]', wave: 'z....|...0..3...3...3...3...3...3...', data: ['IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7', 'IDLE Bit 1,3,5,7','IDLE Bit 1,3,5,7']},\n    ]\n}\n    </code>\n</pre>"},{"location":"astropix5/spi.html#data-rate-considerations","title":"Data Rate Considerations","text":"<p>To determine the minimum SPI clock frequency, the actual rate and the maximum latency needs to be taken into account. The calculations below are minimum values and should be implemented with a safety factor. The fact that the ToA timestamp is only 17 bits wide and that the daisy chain arbiter does prioritize data coming from the chain, relaxes the requirements on the SPI readout clock frequency.</p>"},{"location":"astropix5/spi.html#minimum-data-rate","title":"Minimum Data Rate","text":"<p>The expected maximum hitrate is 10 Hz/sensor. Therefore the maximum data rate is $$ \\textnormal{DR} = 20 \\cdot 10 \\textnormal{Hz} \\cdot 8 \\textnormal{Byte} = 2000 \\textnormal{Byte/s} = 16 \\textnormal{kBit/s} $$</p>"},{"location":"astropix5/spi.html#latency-requirements","title":"Latency Requirements","text":"<p>The minimum latency for a row with n chips and the data rate DR, which is two times the SPI clock rate, for the readout of a hit from the last chip in the row is $$ t_\\textnormal{lat, single hit} = \\dfrac {8 \\textnormal{Byte} + 2 \\textnormal{Byte} \\cdot (n-1)}{\\textnormal{DR}} $$</p> <p>The minimum latency for a row with n chips and the data rate DR, which is two times the SPI clock rate, for the readout of a hit from the last chip with each chip storing data is $$ t_\\textnormal{lat, all hits} = \\dfrac {8 \\textnormal{Byte} \\cdot n}{\\textnormal{DR}} $$</p> <p>The latency has to be shorter than the wrap over time of the 8 bit time-of-arrival timestamp counter. $$ t_\\textnormal{lat} &lt; 2^17 T_\\textnormal{ckts} $$</p> <p>With \\(T_\\textnormal{ckts} = 1/ 20 \\textnormal{MHz}\\) and n = 20, the minimum required data rate DR is ~ 56 kbit/s or an SPI clock of 28 kHz. If all chips have a hit saved the minimum required data rate is ~195 kbit/s or an SPI clock of 98 kHz.</p>"},{"location":"astropix5/spi.html#readout-rate-considerations","title":"Readout Rate Considerations","text":"<p>To select a safe minimum SPI clock frequency, both the expected hit volume and the maximum acceptable readout latency must be considered. The formulas below give minimum values, include an appropriate safety margin when choosing the operating point. Note that the ToA timestamp is 17 bits wide and the daisy-chain arbiter does prioritize forwarded data; both factors relax the required SPI throughput compared to AstroPix3.</p>"},{"location":"astropix5/spi.html#minimum-data-rate_1","title":"Minimum Data Rate","text":"<p>Assuming a maximum hit rate HR, the peak data rate  for a row of n chips is $$ \\text{DR} = n \\cdot \\textnormal{HR} \\cdot 8 ~\\text{Byte} $$</p> <p>Assuming n = 20 and a maximum hit rate HR of 10 Hz/sensor, the data rate DR is 12.8 Kbit/s, requiring a minimum SPI clock frequency of 7 kHz.</p>"},{"location":"astropix5/spi.html#latency-requirements_1","title":"Latency Requirements","text":"<p>Let n be the number of chips in a row and RR the readout rate (RR is twice the SPI clock frequency, as there are 2 MISO lines). The minimum readout latency for a hit originating at the last chip in the row, when only that chip has a hit, is $$ t_{\\text{lat, single hit}} = \\dfrac{8 ~\\text{Byte} + 2 ~\\text{Byte}\\cdot (n-1)}{\\text{RR}} $$</p> <p>If every chip in the row has a stored hit, the minimum latency becomes $$ t_{\\text{lat, all hits}} = \\dfrac{8 ~\\text{Byte}\\cdot n}{\\text{RR}} $$</p> <p>This latency must be shorter than the wrap time of the 17 bit time-of-arrival counter $$ t_{\\text{lat}} &lt; 2^17 ~T_{\\text{ckts}} $$ where \\(T_\\textnormal{ckts}\\) is the timestamp clock period.</p> <p>Using \\(T_\\textnormal{ckts}\\) = 1/20 MHz and n = 20 gives the following practical numbers: the single-hit case requires DR ~ 56 kbit/s (SPI clock = 28 kHz). In the case where every chip has a stored hit, DR ~ 195 kbit/s (SPI clock = 98 kHz).</p> <p>If a slower timestamp clock can be tolerated, the required SPI clock frequency can be reduced accordingly.</p>"},{"location":"astropix5/spi/format_packet_adcreadout.html","title":"Format packet adcreadout","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 8,  name: 'Header', type: 2},\n            {bits: 16,  name: '0xFFFE', type: 3},\n            {bits: 16,  name: 'Temp1', type: 4},\n            {bits: 16,  name: 'Temp2', type: 4},\n            {bits: 8,  name: 'BL', type: 4},\n\n        ], config:{bits: 64, vflip: true}\n    }\n    </code>\n</pre> <pre>    <code>\n    {\n        reg:[\n            {bits: 8,  name: 'Header', type: 2},\n            {bits: 16,  name: '0xFFFD', type: 3},\n            {bits: 8,  name: 'Th', type: 4},\n            {bits: 8,  name: 'Vcasc2', type: 4},\n            {bits: 8,  name: 'GateRef', type: 4},\n            {bits: 8,  name: 'Vminus', type: 4},\n            {bits: 8,  name: 'Vinj', type: 4},\n\n        ], config:{bits: 64, vflip: true}\n    }\n    </code>\n</pre>"},{"location":"astropix5/spi/format_packet_heartbeat.html","title":"Format packet heartbeat","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 8,  name: 'Header', type: 2},\n            {bits: 16,  name: '0xFFFF', type: 3},\n            {bits: 16,  name: 'Extrabits', type: 4},\n            {bits: 16,  name: 'ExtrabitsN', type: 4},\n            {bits: 8,  name: 'SEU Counter', type: 5},\n\n        ], config:{bits: 64, vflip: true}\n    }\n    </code>\n</pre>"},{"location":"astropix5/spi/format_packet_hit.html","title":"Format packet hit","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 8,  name: 'Header', type: 2},\n            {bits: 5,  name: 'Row [4:0]', type: 3},\n            {bits: 5,  name: 'Col [4:0]', type: 3},\n            {bits: 18,  name: 'TS1 Neg, TS1 [16:0]', type: 4},\n            {bits: 5,  name: 'TS1 TDC', type: 4},\n            {bits: 18,  name: 'TS2 Neg, TS2 [16:0]', type: 5},\n            {bits: 5,  name: 'TS2 TDC', type: 5},\n        ], config:{bits: 64, vflip: true}\n    }\n    </code>\n</pre>"},{"location":"astropix5/spi/format_packet_sr.html","title":"Format packet sr","text":"<pre>    <code>\n    {\n        reg:[\n            {bits: 1,  name: 'SIN', type: 2},\n            {bits: 1,  name: 'Load DigConfig', type: 3},\n            {bits: 1,  name: 'Load ColConfig', type: 3},\n            {bits: 1,  name: 'Load TDAC', type: 3},\n            {bits: 1,  name: 'Load Pulsegen', type: 3},\n            {bits: 3,  name: 'Unused', type: 0},\n        ], config:{bits: 8, vflip: false}\n    }\n    </code>\n</pre>"},{"location":"setup/setup.html","title":"Measurement Setup","text":""},{"location":"setup/setup.html#hardware","title":"Hardware","text":""},{"location":"setup/setup.html#chip-carrier-pcbs","title":"Chip Carrier PCBs","text":"<p>The chip carrier PCBs feature a PCIe card edge connector and share the same dimensions W: 51.3 x H: 57.3.</p> <p>The design files including Gerber and assembly data are available on Github:</p> Chipversion EDA Tool Project 1 Altium AstroPix1 PCB 2 KiCAD AstroPix2 PCB 3 KiCAD AstroPix3 PCB 4 KiCAD AstroPix4 PCB"},{"location":"setup/setup.html#gecco-board-configuration","title":"Gecco Board Configuration","text":""},{"location":"setup/setup.html#jumper-settings","title":"Jumper Settings","text":"<ul> <li>RegRst! Set to vdd</li> <li>JPGND Closed</li> <li>JP3V3 Open</li> </ul>"},{"location":"setup/setup.html#resistor-placement","title":"Resistor placement","text":"<p>Place 100\u202f\u03a9 resistors for the LVDS receivers at the following footprints:</p> <ul> <li>R30, R31, R32, R33</li> <li>R25, R26, R27, R28, R29</li> </ul>"},{"location":"setup/setup.html#supply-voltages","title":"Supply Voltages","text":"<p>Two typical configurations are shown for each chip version:</p> <ul> <li>Testing: Minimal number of external supplies (some rails are bridged).</li> <li>Optimal: Each rail is supplied independently for best performance.</li> </ul> Chipversion Configuration Supplies Vminus Chip Carrier Board Jumpers 2 Testing J6=-HV J6, POW6 = VDD18 = 1.8V, VDD33 = 2.7 V Voltagecard Slot 4 JP1: 1-2 2 Optimal J6=-HV J6, POW6 = 1.8 V, VDD18 = 1.8V, VDD33 = 2.7 V Voltagecard Slot 4 JP1: 1-2 3 Testing J6=-HV J6, POW6 = VDD18 = VSSA = 1.8V, VDD33 = 2.7 V Voltagecard Slot 4 JP1: 1-2 3 Optimal J6=-HV J6, POW6 = 1.8 V, VDD18 = 1.8V, VSSA = 1.2V, VDD33 = 2.7 V Voltagecard Slot 4 JP1: 1-2 4 Testing J6=-HV J6, POW6 = VDD18 = VSSA = 1.8V, VDD33 = 2.7 V Voltagecard Slot 5 JP1: 1-2 4 Optimal J6=-HV J6, POW6 = 1.8 V, VDD18 = 1.8V, VSSA = 1.2V, VDD33 = 2.7 V Voltagecard Slot 5 JP1: 1-2 5 Testing J6=-HV J6, POW6 = VDD18 = VSSA = 1.8V, VDD33 = 2.7 V Internally generated JP1: 1-2 5 Optimal J6=-HV J6, POW6 = 1.8 V, VDD18 = 1.8V, VSSA = 1.2V, VDD33 = 2.7 V Internally generated JP1: 1-2"},{"location":"setup/setup.html#software","title":"Software","text":"<p>For using AstroPix2 and AstroPix3 the recommend software and firmware is astep-fw branch:dev_richard. The documentation can be found here.</p> <p>It can also be used for AstroPix4, by using the branch dev_nic.</p> <p>A legacy software, astropix-python together with astropix-fw, is available, supporting all chip versions.</p>"}]}